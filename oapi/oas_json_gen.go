// Code generated by ogen, DO NOT EDIT.

package oapi

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIKeyCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIKeyCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAPIKeyCreateDto = [2]string{
	0: "name",
	1: "permissions",
}

// Decode decodes APIKeyCreateDto from json.
func (s *APIKeyCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeyCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Permissions = make([]Permission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Permission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIKeyCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIKeyCreateDto) {
					name = jsonFieldsNameOfAPIKeyCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeyCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeyCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIKeyCreateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIKeyCreateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiKey")
		s.ApiKey.Encode(e)
	}
	{
		e.FieldStart("secret")
		e.Str(s.Secret)
	}
}

var jsonFieldsNameOfAPIKeyCreateResponseDto = [2]string{
	0: "apiKey",
	1: "secret",
}

// Decode decodes APIKeyCreateResponseDto from json.
func (s *APIKeyCreateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeyCreateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ApiKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		case "secret":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Secret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIKeyCreateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIKeyCreateResponseDto) {
					name = jsonFieldsNameOfAPIKeyCreateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeyCreateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeyCreateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIKeyResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIKeyResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("permissions")
		e.ArrStart()
		for _, elem := range s.Permissions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfAPIKeyResponseDto = [5]string{
	0: "createdAt",
	1: "id",
	2: "name",
	3: "permissions",
	4: "updatedAt",
}

// Decode decodes APIKeyResponseDto from json.
func (s *APIKeyResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeyResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Permissions = make([]Permission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Permission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIKeyResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIKeyResponseDto) {
					name = jsonFieldsNameOfAPIKeyResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeyResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeyResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIKeyUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIKeyUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Permissions != nil {
			e.FieldStart("permissions")
			e.ArrStart()
			for _, elem := range s.Permissions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPIKeyUpdateDto = [2]string{
	0: "name",
	1: "permissions",
}

// Decode decodes APIKeyUpdateDto from json.
func (s *APIKeyUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeyUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions = make([]Permission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Permission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIKeyUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeyUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeyUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityCreateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumId")
		json.EncodeUUID(e, s.AlbumId)
	}
	{
		if s.AssetId.Set {
			e.FieldStart("assetId")
			s.AssetId.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfActivityCreateDto = [4]string{
	0: "albumId",
	1: "assetId",
	2: "comment",
	3: "type",
}

// Decode decodes ActivityCreateDto from json.
func (s *ActivityCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AlbumId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumId\"")
			}
		case "assetId":
			if err := func() error {
				s.AssetId.Reset()
				if err := s.AssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetId\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivityCreateDto) {
					name = jsonFieldsNameOfActivityCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetId")
		s.AssetId.Encode(e)
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfActivityResponseDto = [6]string{
	0: "assetId",
	1: "comment",
	2: "createdAt",
	3: "id",
	4: "type",
	5: "user",
}

// Decode decodes ActivityResponseDto from json.
func (s *ActivityResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetId\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivityResponseDto) {
					name = jsonFieldsNameOfActivityResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivityStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivityStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("comments")
		e.Int(s.Comments)
	}
	{
		e.FieldStart("likes")
		e.Int(s.Likes)
	}
}

var jsonFieldsNameOfActivityStatisticsResponseDto = [2]string{
	0: "comments",
	1: "likes",
}

// Decode decodes ActivityStatisticsResponseDto from json.
func (s *ActivityStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "likes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Likes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"likes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivityStatisticsResponseDto) {
					name = jsonFieldsNameOfActivityStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivityStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivityStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUsersDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumUsers")
		e.ArrStart()
		for _, elem := range s.AlbumUsers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAddUsersDto = [1]string{
	0: "albumUsers",
}

// Decode decodes AddUsersDto from json.
func (s *AddUsersDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumUsers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AlbumUsers = make([]AlbumUserAddDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlbumUserAddDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlbumUsers = append(s.AlbumUsers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumUsers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersDto) {
					name = jsonFieldsNameOfAddUsersDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdminOnboardingUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdminOnboardingUpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isOnboarded")
		e.Bool(s.IsOnboarded)
	}
}

var jsonFieldsNameOfAdminOnboardingUpdateDto = [1]string{
	0: "isOnboarded",
}

// Decode decodes AdminOnboardingUpdateDto from json.
func (s *AdminOnboardingUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminOnboardingUpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isOnboarded":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboarded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOnboarded\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdminOnboardingUpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdminOnboardingUpdateDto) {
					name = jsonFieldsNameOfAdminOnboardingUpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminOnboardingUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminOnboardingUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumName")
		e.Str(s.AlbumName)
	}
	{
		e.FieldStart("albumThumbnailAssetId")
		s.AlbumThumbnailAssetId.Encode(e)
	}
	{
		e.FieldStart("albumUsers")
		e.ArrStart()
		for _, elem := range s.AlbumUsers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("assetCount")
		e.Int(s.AssetCount)
	}
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ContributorCounts != nil {
			e.FieldStart("contributorCounts")
			e.ArrStart()
			for _, elem := range s.ContributorCounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.EndDate.Set {
			e.FieldStart("endDate")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("hasSharedLink")
		e.Bool(s.HasSharedLink)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isActivityEnabled")
		e.Bool(s.IsActivityEnabled)
	}
	{
		if s.LastModifiedAssetTimestamp.Set {
			e.FieldStart("lastModifiedAssetTimestamp")
			s.LastModifiedAssetTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("ownerId")
		e.Str(s.OwnerId)
	}
	{
		e.FieldStart("shared")
		e.Bool(s.Shared)
	}
	{
		if s.StartDate.Set {
			e.FieldStart("startDate")
			s.StartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfAlbumResponseDto = [19]string{
	0:  "albumName",
	1:  "albumThumbnailAssetId",
	2:  "albumUsers",
	3:  "assetCount",
	4:  "assets",
	5:  "contributorCounts",
	6:  "createdAt",
	7:  "description",
	8:  "endDate",
	9:  "hasSharedLink",
	10: "id",
	11: "isActivityEnabled",
	12: "lastModifiedAssetTimestamp",
	13: "order",
	14: "owner",
	15: "ownerId",
	16: "shared",
	17: "startDate",
	18: "updatedAt",
}

// Decode decodes AlbumResponseDto from json.
func (s *AlbumResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumResponseDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AlbumName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumName\"")
			}
		case "albumThumbnailAssetId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AlbumThumbnailAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumThumbnailAssetId\"")
			}
		case "albumUsers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AlbumUsers = make([]AlbumUserResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlbumUserResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlbumUsers = append(s.AlbumUsers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumUsers\"")
			}
		case "assetCount":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AssetCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetCount\"")
			}
		case "assets":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Assets = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "contributorCounts":
			if err := func() error {
				s.ContributorCounts = make([]ContributorCountResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContributorCountResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ContributorCounts = append(s.ContributorCounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributorCounts\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "endDate":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endDate\"")
			}
		case "hasSharedLink":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasSharedLink = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasSharedLink\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isActivityEnabled":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsActivityEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActivityEnabled\"")
			}
		case "lastModifiedAssetTimestamp":
			if err := func() error {
				s.LastModifiedAssetTimestamp.Reset()
				if err := s.LastModifiedAssetTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModifiedAssetTimestamp\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "ownerId":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.OwnerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		case "shared":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Shared = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared\"")
			}
		case "startDate":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11011111,
		0b11001110,
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumResponseDto) {
					name = jsonFieldsNameOfAlbumResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("notShared")
		e.Int(s.NotShared)
	}
	{
		e.FieldStart("owned")
		e.Int(s.Owned)
	}
	{
		e.FieldStart("shared")
		e.Int(s.Shared)
	}
}

var jsonFieldsNameOfAlbumStatisticsResponseDto = [3]string{
	0: "notShared",
	1: "owned",
	2: "shared",
}

// Decode decodes AlbumStatisticsResponseDto from json.
func (s *AlbumStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "notShared":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.NotShared = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notShared\"")
			}
		case "owned":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Owned = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned\"")
			}
		case "shared":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Shared = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumStatisticsResponseDto) {
					name = jsonFieldsNameOfAlbumStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumUserAddDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumUserAddDto) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		e.FieldStart("userId")
		json.EncodeUUID(e, s.UserId)
	}
}

var jsonFieldsNameOfAlbumUserAddDto = [2]string{
	0: "role",
	1: "userId",
}

// Decode decodes AlbumUserAddDto from json.
func (s *AlbumUserAddDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumUserAddDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumUserAddDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumUserAddDto) {
					name = jsonFieldsNameOfAlbumUserAddDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumUserAddDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumUserAddDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumUserCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumUserCreateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("userId")
		json.EncodeUUID(e, s.UserId)
	}
}

var jsonFieldsNameOfAlbumUserCreateDto = [2]string{
	0: "role",
	1: "userId",
}

// Decode decodes AlbumUserCreateDto from json.
func (s *AlbumUserCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumUserCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumUserCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumUserCreateDto) {
					name = jsonFieldsNameOfAlbumUserCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumUserCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumUserCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfAlbumUserResponseDto = [2]string{
	0: "role",
	1: "user",
}

// Decode decodes AlbumUserResponseDto from json.
func (s *AlbumUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumUserResponseDto) {
					name = jsonFieldsNameOfAlbumUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlbumUserRole as json.
func (s AlbumUserRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlbumUserRole from json.
func (s *AlbumUserRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumUserRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlbumUserRole(v) {
	case AlbumUserRoleEditor:
		*s = AlbumUserRoleEditor
	case AlbumUserRoleViewer:
		*s = AlbumUserRoleViewer
	default:
		*s = AlbumUserRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlbumUserRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumUserRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumsAddAssetsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumsAddAssetsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumIds")
		e.ArrStart()
		for _, elem := range s.AlbumIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("assetIds")
		e.ArrStart()
		for _, elem := range s.AssetIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAlbumsAddAssetsDto = [2]string{
	0: "albumIds",
	1: "assetIds",
}

// Decode decodes AlbumsAddAssetsDto from json.
func (s *AlbumsAddAssetsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumsAddAssetsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AlbumIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AlbumIds = append(s.AlbumIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumIds\"")
			}
		case "assetIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumsAddAssetsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumsAddAssetsDto) {
					name = jsonFieldsNameOfAlbumsAddAssetsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumsAddAssetsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumsAddAssetsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumsAddAssetsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumsAddAssetsResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfAlbumsAddAssetsResponseDto = [2]string{
	0: "error",
	1: "success",
}

// Decode decodes AlbumsAddAssetsResponseDto from json.
func (s *AlbumsAddAssetsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumsAddAssetsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumsAddAssetsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumsAddAssetsResponseDto) {
					name = jsonFieldsNameOfAlbumsAddAssetsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumsAddAssetsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumsAddAssetsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("defaultAssetOrder")
		s.DefaultAssetOrder.Encode(e)
	}
}

var jsonFieldsNameOfAlbumsResponse = [1]string{
	0: "defaultAssetOrder",
}

// Decode decodes AlbumsResponse from json.
func (s *AlbumsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultAssetOrder":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DefaultAssetOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAssetOrder\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlbumsResponse) {
					name = jsonFieldsNameOfAlbumsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlbumsUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlbumsUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultAssetOrder.Set {
			e.FieldStart("defaultAssetOrder")
			s.DefaultAssetOrder.Encode(e)
		}
	}
}

var jsonFieldsNameOfAlbumsUpdate = [1]string{
	0: "defaultAssetOrder",
}

// Decode decodes AlbumsUpdate from json.
func (s *AlbumsUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlbumsUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultAssetOrder":
			if err := func() error {
				s.DefaultAssetOrder.Reset()
				if err := s.DefaultAssetOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultAssetOrder\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlbumsUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlbumsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlbumsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AllJobStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AllJobStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backgroundTask")
		s.BackgroundTask.Encode(e)
	}
	{
		e.FieldStart("backupDatabase")
		s.BackupDatabase.Encode(e)
	}
	{
		e.FieldStart("duplicateDetection")
		s.DuplicateDetection.Encode(e)
	}
	{
		e.FieldStart("faceDetection")
		s.FaceDetection.Encode(e)
	}
	{
		e.FieldStart("facialRecognition")
		s.FacialRecognition.Encode(e)
	}
	{
		e.FieldStart("library")
		s.Library.Encode(e)
	}
	{
		e.FieldStart("metadataExtraction")
		s.MetadataExtraction.Encode(e)
	}
	{
		e.FieldStart("migration")
		s.Migration.Encode(e)
	}
	{
		e.FieldStart("notifications")
		s.Notifications.Encode(e)
	}
	{
		e.FieldStart("search")
		s.Search.Encode(e)
	}
	{
		e.FieldStart("sidecar")
		s.Sidecar.Encode(e)
	}
	{
		e.FieldStart("smartSearch")
		s.SmartSearch.Encode(e)
	}
	{
		e.FieldStart("storageTemplateMigration")
		s.StorageTemplateMigration.Encode(e)
	}
	{
		e.FieldStart("thumbnailGeneration")
		s.ThumbnailGeneration.Encode(e)
	}
	{
		e.FieldStart("videoConversion")
		s.VideoConversion.Encode(e)
	}
}

var jsonFieldsNameOfAllJobStatusResponseDto = [15]string{
	0:  "backgroundTask",
	1:  "backupDatabase",
	2:  "duplicateDetection",
	3:  "faceDetection",
	4:  "facialRecognition",
	5:  "library",
	6:  "metadataExtraction",
	7:  "migration",
	8:  "notifications",
	9:  "search",
	10: "sidecar",
	11: "smartSearch",
	12: "storageTemplateMigration",
	13: "thumbnailGeneration",
	14: "videoConversion",
}

// Decode decodes AllJobStatusResponseDto from json.
func (s *AllJobStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllJobStatusResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backgroundTask":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BackgroundTask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backgroundTask\"")
			}
		case "backupDatabase":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BackupDatabase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backupDatabase\"")
			}
		case "duplicateDetection":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DuplicateDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateDetection\"")
			}
		case "faceDetection":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaceDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faceDetection\"")
			}
		case "facialRecognition":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FacialRecognition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facialRecognition\"")
			}
		case "library":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Library.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"library\"")
			}
		case "metadataExtraction":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.MetadataExtraction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadataExtraction\"")
			}
		case "migration":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		case "notifications":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Notifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "search":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Search.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search\"")
			}
		case "sidecar":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Sidecar.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidecar\"")
			}
		case "smartSearch":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.SmartSearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smartSearch\"")
			}
		case "storageTemplateMigration":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.StorageTemplateMigration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageTemplateMigration\"")
			}
		case "thumbnailGeneration":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.ThumbnailGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnailGeneration\"")
			}
		case "videoConversion":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.VideoConversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videoConversion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AllJobStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAllJobStatusResponseDto) {
					name = jsonFieldsNameOfAllJobStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AllJobStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AllJobStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetBulkDeleteDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetBulkDeleteDto) encodeFields(e *jx.Encoder) {
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetBulkDeleteDto = [2]string{
	0: "force",
	1: "ids",
}

// Decode decodes AssetBulkDeleteDto from json.
func (s *AssetBulkDeleteDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkDeleteDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		case "ids":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetBulkDeleteDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetBulkDeleteDto) {
					name = jsonFieldsNameOfAssetBulkDeleteDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetBulkDeleteDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkDeleteDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetBulkUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetBulkUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.DateTimeOriginal.Set {
			e.FieldStart("dateTimeOriginal")
			s.DateTimeOriginal.Encode(e)
		}
	}
	{
		if s.DateTimeRelative.Set {
			e.FieldStart("dateTimeRelative")
			s.DateTimeRelative.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DuplicateId.Set {
			e.FieldStart("duplicateId")
			s.DuplicateId.Encode(e)
		}
	}
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.TimeZone.Set {
			e.FieldStart("timeZone")
			s.TimeZone.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssetBulkUpdateDto = [11]string{
	0:  "dateTimeOriginal",
	1:  "dateTimeRelative",
	2:  "description",
	3:  "duplicateId",
	4:  "ids",
	5:  "isFavorite",
	6:  "latitude",
	7:  "longitude",
	8:  "rating",
	9:  "timeZone",
	10: "visibility",
}

// Decode decodes AssetBulkUpdateDto from json.
func (s *AssetBulkUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUpdateDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dateTimeOriginal":
			if err := func() error {
				s.DateTimeOriginal.Reset()
				if err := s.DateTimeOriginal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTimeOriginal\"")
			}
		case "dateTimeRelative":
			if err := func() error {
				s.DateTimeRelative.Reset()
				if err := s.DateTimeRelative.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTimeRelative\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "duplicateId":
			if err := func() error {
				s.DuplicateId.Reset()
				if err := s.DuplicateId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateId\"")
			}
		case "ids":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "timeZone":
			if err := func() error {
				s.TimeZone.Reset()
				if err := s.TimeZone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeZone\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetBulkUpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetBulkUpdateDto) {
					name = jsonFieldsNameOfAssetBulkUpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetBulkUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetBulkUploadCheckDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetBulkUploadCheckDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetBulkUploadCheckDto = [1]string{
	0: "assets",
}

// Decode decodes AssetBulkUploadCheckDto from json.
func (s *AssetBulkUploadCheckDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUploadCheckDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Assets = make([]AssetBulkUploadCheckItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetBulkUploadCheckItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetBulkUploadCheckDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetBulkUploadCheckDto) {
					name = jsonFieldsNameOfAssetBulkUploadCheckDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetBulkUploadCheckDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUploadCheckDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetBulkUploadCheckItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetBulkUploadCheckItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("checksum")
		e.Str(s.Checksum)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfAssetBulkUploadCheckItem = [2]string{
	0: "checksum",
	1: "id",
}

// Decode decodes AssetBulkUploadCheckItem from json.
func (s *AssetBulkUploadCheckItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUploadCheckItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "checksum":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Checksum = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checksum\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetBulkUploadCheckItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetBulkUploadCheckItem) {
					name = jsonFieldsNameOfAssetBulkUploadCheckItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetBulkUploadCheckItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUploadCheckItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetBulkUploadCheckResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetBulkUploadCheckResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetBulkUploadCheckResponseDto = [1]string{
	0: "results",
}

// Decode decodes AssetBulkUploadCheckResponseDto from json.
func (s *AssetBulkUploadCheckResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUploadCheckResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]AssetBulkUploadCheckResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetBulkUploadCheckResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetBulkUploadCheckResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetBulkUploadCheckResponseDto) {
					name = jsonFieldsNameOfAssetBulkUploadCheckResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetBulkUploadCheckResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUploadCheckResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetBulkUploadCheckResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetBulkUploadCheckResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		if s.AssetId.Set {
			e.FieldStart("assetId")
			s.AssetId.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsTrashed.Set {
			e.FieldStart("isTrashed")
			s.IsTrashed.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssetBulkUploadCheckResult = [5]string{
	0: "action",
	1: "assetId",
	2: "id",
	3: "isTrashed",
	4: "reason",
}

// Decode decodes AssetBulkUploadCheckResult from json.
func (s *AssetBulkUploadCheckResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUploadCheckResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "assetId":
			if err := func() error {
				s.AssetId.Reset()
				if err := s.AssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetId\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isTrashed":
			if err := func() error {
				s.IsTrashed.Reset()
				if err := s.IsTrashed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrashed\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetBulkUploadCheckResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetBulkUploadCheckResult) {
					name = jsonFieldsNameOfAssetBulkUploadCheckResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetBulkUploadCheckResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUploadCheckResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetBulkUploadCheckResultAction as json.
func (s AssetBulkUploadCheckResultAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetBulkUploadCheckResultAction from json.
func (s *AssetBulkUploadCheckResultAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUploadCheckResultAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetBulkUploadCheckResultAction(v) {
	case AssetBulkUploadCheckResultActionAccept:
		*s = AssetBulkUploadCheckResultActionAccept
	case AssetBulkUploadCheckResultActionReject:
		*s = AssetBulkUploadCheckResultActionReject
	default:
		*s = AssetBulkUploadCheckResultAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetBulkUploadCheckResultAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUploadCheckResultAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetBulkUploadCheckResultReason as json.
func (s AssetBulkUploadCheckResultReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetBulkUploadCheckResultReason from json.
func (s *AssetBulkUploadCheckResultReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetBulkUploadCheckResultReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetBulkUploadCheckResultReason(v) {
	case AssetBulkUploadCheckResultReasonDuplicate:
		*s = AssetBulkUploadCheckResultReasonDuplicate
	case AssetBulkUploadCheckResultReasonUnsupportedFormat:
		*s = AssetBulkUploadCheckResultReasonUnsupportedFormat
	default:
		*s = AssetBulkUploadCheckResultReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetBulkUploadCheckResultReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetBulkUploadCheckResultReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetDeltaSyncDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetDeltaSyncDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("updatedAfter")
		json.EncodeDateTime(e, s.UpdatedAfter)
	}
	{
		e.FieldStart("userIds")
		e.ArrStart()
		for _, elem := range s.UserIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetDeltaSyncDto = [2]string{
	0: "updatedAfter",
	1: "userIds",
}

// Decode decodes AssetDeltaSyncDto from json.
func (s *AssetDeltaSyncDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetDeltaSyncDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updatedAfter":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAfter = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAfter\"")
			}
		case "userIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.UserIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.UserIds = append(s.UserIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetDeltaSyncDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetDeltaSyncDto) {
					name = jsonFieldsNameOfAssetDeltaSyncDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetDeltaSyncDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetDeltaSyncDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetDeltaSyncResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetDeltaSyncResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("deleted")
		e.ArrStart()
		for _, elem := range s.Deleted {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("needsFullSync")
		e.Bool(s.NeedsFullSync)
	}
	{
		e.FieldStart("upserted")
		e.ArrStart()
		for _, elem := range s.Upserted {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetDeltaSyncResponseDto = [3]string{
	0: "deleted",
	1: "needsFullSync",
	2: "upserted",
}

// Decode decodes AssetDeltaSyncResponseDto from json.
func (s *AssetDeltaSyncResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetDeltaSyncResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Deleted = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Deleted = append(s.Deleted, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		case "needsFullSync":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.NeedsFullSync = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needsFullSync\"")
			}
		case "upserted":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Upserted = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Upserted = append(s.Upserted, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upserted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetDeltaSyncResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetDeltaSyncResponseDto) {
					name = jsonFieldsNameOfAssetDeltaSyncResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetDeltaSyncResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetDeltaSyncResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFaceCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFaceCreateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetId")
		json.EncodeUUID(e, s.AssetId)
	}
	{
		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		e.FieldStart("imageHeight")
		e.Int(s.ImageHeight)
	}
	{
		e.FieldStart("imageWidth")
		e.Int(s.ImageWidth)
	}
	{
		e.FieldStart("personId")
		json.EncodeUUID(e, s.PersonId)
	}
	{
		e.FieldStart("width")
		e.Int(s.Width)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfAssetFaceCreateDto = [8]string{
	0: "assetId",
	1: "height",
	2: "imageHeight",
	3: "imageWidth",
	4: "personId",
	5: "width",
	6: "x",
	7: "y",
}

// Decode decodes AssetFaceCreateDto from json.
func (s *AssetFaceCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFaceCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AssetId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetId\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "imageHeight":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ImageHeight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageHeight\"")
			}
		case "imageWidth":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ImageWidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageWidth\"")
			}
		case "personId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PersonId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personId\"")
			}
		case "width":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFaceCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFaceCreateDto) {
					name = jsonFieldsNameOfAssetFaceCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFaceCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFaceCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFaceDeleteDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFaceDeleteDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("force")
		e.Bool(s.Force)
	}
}

var jsonFieldsNameOfAssetFaceDeleteDto = [1]string{
	0: "force",
}

// Decode decodes AssetFaceDeleteDto from json.
func (s *AssetFaceDeleteDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFaceDeleteDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Force = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFaceDeleteDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFaceDeleteDto) {
					name = jsonFieldsNameOfAssetFaceDeleteDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFaceDeleteDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFaceDeleteDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFaceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFaceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("boundingBoxX1")
		e.Int(s.BoundingBoxX1)
	}
	{
		e.FieldStart("boundingBoxX2")
		e.Int(s.BoundingBoxX2)
	}
	{
		e.FieldStart("boundingBoxY1")
		e.Int(s.BoundingBoxY1)
	}
	{
		e.FieldStart("boundingBoxY2")
		e.Int(s.BoundingBoxY2)
	}
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("imageHeight")
		e.Int(s.ImageHeight)
	}
	{
		e.FieldStart("imageWidth")
		e.Int(s.ImageWidth)
	}
	{
		e.FieldStart("person")
		s.Person.Encode(e)
	}
	{
		if s.SourceType.Set {
			e.FieldStart("sourceType")
			s.SourceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssetFaceResponseDto = [9]string{
	0: "boundingBoxX1",
	1: "boundingBoxX2",
	2: "boundingBoxY1",
	3: "boundingBoxY2",
	4: "id",
	5: "imageHeight",
	6: "imageWidth",
	7: "person",
	8: "sourceType",
}

// Decode decodes AssetFaceResponseDto from json.
func (s *AssetFaceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFaceResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "boundingBoxX1":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxX1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxX1\"")
			}
		case "boundingBoxX2":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxX2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxX2\"")
			}
		case "boundingBoxY1":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxY1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxY1\"")
			}
		case "boundingBoxY2":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxY2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxY2\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "imageHeight":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ImageHeight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageHeight\"")
			}
		case "imageWidth":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ImageWidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageWidth\"")
			}
		case "person":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Person.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"person\"")
			}
		case "sourceType":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFaceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFaceResponseDto) {
					name = jsonFieldsNameOfAssetFaceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFaceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFaceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFaceUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFaceUpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetFaceUpdateDto = [1]string{
	0: "data",
}

// Decode decodes AssetFaceUpdateDto from json.
func (s *AssetFaceUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFaceUpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AssetFaceUpdateItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetFaceUpdateItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFaceUpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFaceUpdateDto) {
					name = jsonFieldsNameOfAssetFaceUpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFaceUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFaceUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFaceUpdateItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFaceUpdateItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetId")
		json.EncodeUUID(e, s.AssetId)
	}
	{
		e.FieldStart("personId")
		json.EncodeUUID(e, s.PersonId)
	}
}

var jsonFieldsNameOfAssetFaceUpdateItem = [2]string{
	0: "assetId",
	1: "personId",
}

// Decode decodes AssetFaceUpdateItem from json.
func (s *AssetFaceUpdateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFaceUpdateItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.AssetId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetId\"")
			}
		case "personId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PersonId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFaceUpdateItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFaceUpdateItem) {
					name = jsonFieldsNameOfAssetFaceUpdateItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFaceUpdateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFaceUpdateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFaceWithoutPersonResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFaceWithoutPersonResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("boundingBoxX1")
		e.Int(s.BoundingBoxX1)
	}
	{
		e.FieldStart("boundingBoxX2")
		e.Int(s.BoundingBoxX2)
	}
	{
		e.FieldStart("boundingBoxY1")
		e.Int(s.BoundingBoxY1)
	}
	{
		e.FieldStart("boundingBoxY2")
		e.Int(s.BoundingBoxY2)
	}
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("imageHeight")
		e.Int(s.ImageHeight)
	}
	{
		e.FieldStart("imageWidth")
		e.Int(s.ImageWidth)
	}
	{
		if s.SourceType.Set {
			e.FieldStart("sourceType")
			s.SourceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssetFaceWithoutPersonResponseDto = [8]string{
	0: "boundingBoxX1",
	1: "boundingBoxX2",
	2: "boundingBoxY1",
	3: "boundingBoxY2",
	4: "id",
	5: "imageHeight",
	6: "imageWidth",
	7: "sourceType",
}

// Decode decodes AssetFaceWithoutPersonResponseDto from json.
func (s *AssetFaceWithoutPersonResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFaceWithoutPersonResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "boundingBoxX1":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxX1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxX1\"")
			}
		case "boundingBoxX2":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxX2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxX2\"")
			}
		case "boundingBoxY1":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxY1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxY1\"")
			}
		case "boundingBoxY2":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.BoundingBoxY2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boundingBoxY2\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "imageHeight":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ImageHeight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageHeight\"")
			}
		case "imageWidth":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ImageWidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageWidth\"")
			}
		case "sourceType":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFaceWithoutPersonResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFaceWithoutPersonResponseDto) {
					name = jsonFieldsNameOfAssetFaceWithoutPersonResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFaceWithoutPersonResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFaceWithoutPersonResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetFullSyncDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetFullSyncDto) encodeFields(e *jx.Encoder) {
	{
		if s.LastId.Set {
			e.FieldStart("lastId")
			s.LastId.Encode(e)
		}
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("updatedUntil")
		json.EncodeDateTime(e, s.UpdatedUntil)
	}
	{
		if s.UserId.Set {
			e.FieldStart("userId")
			s.UserId.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssetFullSyncDto = [4]string{
	0: "lastId",
	1: "limit",
	2: "updatedUntil",
	3: "userId",
}

// Decode decodes AssetFullSyncDto from json.
func (s *AssetFullSyncDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetFullSyncDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastId":
			if err := func() error {
				s.LastId.Reset()
				if err := s.LastId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastId\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "updatedUntil":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedUntil = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedUntil\"")
			}
		case "userId":
			if err := func() error {
				s.UserId.Reset()
				if err := s.UserId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetFullSyncDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetFullSyncDto) {
					name = jsonFieldsNameOfAssetFullSyncDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetFullSyncDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetFullSyncDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetIdsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetIdsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetIds")
		e.ArrStart()
		for _, elem := range s.AssetIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetIdsDto = [1]string{
	0: "assetIds",
}

// Decode decodes AssetIdsDto from json.
func (s *AssetIdsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetIdsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetIdsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetIdsDto) {
					name = jsonFieldsNameOfAssetIdsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetIdsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetIdsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetIdsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetIdsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetId")
		e.Str(s.AssetId)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfAssetIdsResponseDto = [3]string{
	0: "assetId",
	1: "error",
	2: "success",
}

// Decode decodes AssetIdsResponseDto from json.
func (s *AssetIdsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetIdsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AssetId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetId\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetIdsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetIdsResponseDto) {
					name = jsonFieldsNameOfAssetIdsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetIdsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetIdsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetIdsResponseDtoError as json.
func (s AssetIdsResponseDtoError) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetIdsResponseDtoError from json.
func (s *AssetIdsResponseDtoError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetIdsResponseDtoError to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetIdsResponseDtoError(v) {
	case AssetIdsResponseDtoErrorDuplicate:
		*s = AssetIdsResponseDtoErrorDuplicate
	case AssetIdsResponseDtoErrorNoPermission:
		*s = AssetIdsResponseDtoErrorNoPermission
	case AssetIdsResponseDtoErrorNotFound:
		*s = AssetIdsResponseDtoErrorNotFound
	default:
		*s = AssetIdsResponseDtoError(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetIdsResponseDtoError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetIdsResponseDtoError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetJobName as json.
func (s AssetJobName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetJobName from json.
func (s *AssetJobName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetJobName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetJobName(v) {
	case AssetJobNameRefreshFaces:
		*s = AssetJobNameRefreshFaces
	case AssetJobNameRefreshMetadata:
		*s = AssetJobNameRefreshMetadata
	case AssetJobNameRegenerateThumbnail:
		*s = AssetJobNameRegenerateThumbnail
	case AssetJobNameTranscodeVideo:
		*s = AssetJobNameTranscodeVideo
	default:
		*s = AssetJobName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetJobName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetJobName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetJobsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetJobsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetIds")
		e.ArrStart()
		for _, elem := range s.AssetIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
}

var jsonFieldsNameOfAssetJobsDto = [2]string{
	0: "assetIds",
	1: "name",
}

// Decode decodes AssetJobsDto from json.
func (s *AssetJobsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetJobsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetJobsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetJobsDto) {
					name = jsonFieldsNameOfAssetJobsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetJobsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetJobsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetMediaResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetMediaResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfAssetMediaResponseDto = [2]string{
	0: "id",
	1: "status",
}

// Decode decodes AssetMediaResponseDto from json.
func (s *AssetMediaResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMediaResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetMediaResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetMediaResponseDto) {
					name = jsonFieldsNameOfAssetMediaResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetMediaResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMediaResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetMediaStatus as json.
func (s AssetMediaStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetMediaStatus from json.
func (s *AssetMediaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMediaStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetMediaStatus(v) {
	case AssetMediaStatusCreated:
		*s = AssetMediaStatusCreated
	case AssetMediaStatusReplaced:
		*s = AssetMediaStatusReplaced
	case AssetMediaStatusDuplicate:
		*s = AssetMediaStatusDuplicate
	default:
		*s = AssetMediaStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetMediaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMediaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetMetadataKey as json.
func (s AssetMetadataKey) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetMetadataKey from json.
func (s *AssetMetadataKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMetadataKey to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetMetadataKey(v) {
	case AssetMetadataKeyMobileApp:
		*s = AssetMetadataKeyMobileApp
	default:
		*s = AssetMetadataKey(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetMetadataKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMetadataKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetMetadataResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetMetadataResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		s.Key.Encode(e)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfAssetMetadataResponseDto = [3]string{
	0: "key",
	1: "updatedAt",
	2: "value",
}

// Decode decodes AssetMetadataResponseDto from json.
func (s *AssetMetadataResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMetadataResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetMetadataResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetMetadataResponseDto) {
					name = jsonFieldsNameOfAssetMetadataResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetMetadataResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMetadataResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetMetadataResponseDtoValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetMetadataResponseDtoValue) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAssetMetadataResponseDtoValue = [0]string{}

// Decode decodes AssetMetadataResponseDtoValue from json.
func (s *AssetMetadataResponseDtoValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMetadataResponseDtoValue to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AssetMetadataResponseDtoValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetMetadataResponseDtoValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMetadataResponseDtoValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetMetadataUpsertDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetMetadataUpsertDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAssetMetadataUpsertDto = [1]string{
	0: "items",
}

// Decode decodes AssetMetadataUpsertDto from json.
func (s *AssetMetadataUpsertDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMetadataUpsertDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]AssetMetadataUpsertItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetMetadataUpsertItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetMetadataUpsertDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetMetadataUpsertDto) {
					name = jsonFieldsNameOfAssetMetadataUpsertDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetMetadataUpsertDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMetadataUpsertDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetMetadataUpsertItemDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetMetadataUpsertItemDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		s.Key.Encode(e)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfAssetMetadataUpsertItemDto = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes AssetMetadataUpsertItemDto from json.
func (s *AssetMetadataUpsertItemDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMetadataUpsertItemDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetMetadataUpsertItemDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetMetadataUpsertItemDto) {
					name = jsonFieldsNameOfAssetMetadataUpsertItemDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetMetadataUpsertItemDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMetadataUpsertItemDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetMetadataUpsertItemDtoValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetMetadataUpsertItemDtoValue) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAssetMetadataUpsertItemDtoValue = [0]string{}

// Decode decodes AssetMetadataUpsertItemDtoValue from json.
func (s *AssetMetadataUpsertItemDtoValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetMetadataUpsertItemDtoValue to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AssetMetadataUpsertItemDtoValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetMetadataUpsertItemDtoValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetMetadataUpsertItemDtoValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetOrder as json.
func (s AssetOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetOrder from json.
func (s *AssetOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetOrder to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetOrder(v) {
	case AssetOrderAsc:
		*s = AssetOrderAsc
	case AssetOrderDesc:
		*s = AssetOrderDesc
	default:
		*s = AssetOrder(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("checksum")
		e.Str(s.Checksum)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("deviceAssetId")
		e.Str(s.DeviceAssetId)
	}
	{
		e.FieldStart("deviceId")
		e.Str(s.DeviceId)
	}
	{
		if s.DuplicateId.Set {
			e.FieldStart("duplicateId")
			s.DuplicateId.Encode(e)
		}
	}
	{
		e.FieldStart("duration")
		e.Str(s.Duration)
	}
	{
		if s.ExifInfo.Set {
			e.FieldStart("exifInfo")
			s.ExifInfo.Encode(e)
		}
	}
	{
		e.FieldStart("fileCreatedAt")
		json.EncodeDateTime(e, s.FileCreatedAt)
	}
	{
		e.FieldStart("fileModifiedAt")
		json.EncodeDateTime(e, s.FileModifiedAt)
	}
	{
		e.FieldStart("hasMetadata")
		e.Bool(s.HasMetadata)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isArchived")
		e.Bool(s.IsArchived)
	}
	{
		e.FieldStart("isFavorite")
		e.Bool(s.IsFavorite)
	}
	{
		e.FieldStart("isOffline")
		e.Bool(s.IsOffline)
	}
	{
		e.FieldStart("isTrashed")
		e.Bool(s.IsTrashed)
	}
	{
		if s.LibraryId.Set {
			e.FieldStart("libraryId")
			s.LibraryId.Encode(e)
		}
	}
	{
		if s.LivePhotoVideoId.Set {
			e.FieldStart("livePhotoVideoId")
			s.LivePhotoVideoId.Encode(e)
		}
	}
	{
		e.FieldStart("localDateTime")
		json.EncodeDateTime(e, s.LocalDateTime)
	}
	{
		e.FieldStart("originalFileName")
		e.Str(s.OriginalFileName)
	}
	{
		if s.OriginalMimeType.Set {
			e.FieldStart("originalMimeType")
			s.OriginalMimeType.Encode(e)
		}
	}
	{
		e.FieldStart("originalPath")
		e.Str(s.OriginalPath)
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		e.FieldStart("ownerId")
		e.Str(s.OwnerId)
	}
	{
		if s.People != nil {
			e.FieldStart("people")
			e.ArrStart()
			for _, elem := range s.People {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resized.Set {
			e.FieldStart("resized")
			s.Resized.Encode(e)
		}
	}
	{
		if s.Stack.Set {
			e.FieldStart("stack")
			s.Stack.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("thumbhash")
		s.Thumbhash.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.UnassignedFaces != nil {
			e.FieldStart("unassignedFaces")
			e.ArrStart()
			for _, elem := range s.UnassignedFaces {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
}

var jsonFieldsNameOfAssetResponseDto = [32]string{
	0:  "checksum",
	1:  "createdAt",
	2:  "deviceAssetId",
	3:  "deviceId",
	4:  "duplicateId",
	5:  "duration",
	6:  "exifInfo",
	7:  "fileCreatedAt",
	8:  "fileModifiedAt",
	9:  "hasMetadata",
	10: "id",
	11: "isArchived",
	12: "isFavorite",
	13: "isOffline",
	14: "isTrashed",
	15: "libraryId",
	16: "livePhotoVideoId",
	17: "localDateTime",
	18: "originalFileName",
	19: "originalMimeType",
	20: "originalPath",
	21: "owner",
	22: "ownerId",
	23: "people",
	24: "resized",
	25: "stack",
	26: "tags",
	27: "thumbhash",
	28: "type",
	29: "unassignedFaces",
	30: "updatedAt",
	31: "visibility",
}

// Decode decodes AssetResponseDto from json.
func (s *AssetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetResponseDto to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "checksum":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Checksum = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checksum\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "deviceAssetId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DeviceAssetId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceAssetId\"")
			}
		case "deviceId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DeviceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceId\"")
			}
		case "duplicateId":
			if err := func() error {
				s.DuplicateId.Reset()
				if err := s.DuplicateId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateId\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Duration = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "exifInfo":
			if err := func() error {
				s.ExifInfo.Reset()
				if err := s.ExifInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exifInfo\"")
			}
		case "fileCreatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.FileCreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileCreatedAt\"")
			}
		case "fileModifiedAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.FileModifiedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileModifiedAt\"")
			}
		case "hasMetadata":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMetadata = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMetadata\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isArchived":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsArchived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isArchived\"")
			}
		case "isFavorite":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsFavorite = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isOffline":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsOffline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOffline\"")
			}
		case "isTrashed":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrashed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrashed\"")
			}
		case "libraryId":
			if err := func() error {
				s.LibraryId.Reset()
				if err := s.LibraryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"libraryId\"")
			}
		case "livePhotoVideoId":
			if err := func() error {
				s.LivePhotoVideoId.Reset()
				if err := s.LivePhotoVideoId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livePhotoVideoId\"")
			}
		case "localDateTime":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LocalDateTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localDateTime\"")
			}
		case "originalFileName":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OriginalFileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalFileName\"")
			}
		case "originalMimeType":
			if err := func() error {
				s.OriginalMimeType.Reset()
				if err := s.OriginalMimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalMimeType\"")
			}
		case "originalPath":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.OriginalPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalPath\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "ownerId":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.OwnerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		case "people":
			if err := func() error {
				s.People = make([]PersonWithFacesResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonWithFacesResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.People = append(s.People, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"people\"")
			}
		case "resized":
			if err := func() error {
				s.Resized.Reset()
				if err := s.Resized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resized\"")
			}
		case "stack":
			if err := func() error {
				s.Stack.Reset()
				if err := s.Stack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stack\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]TagResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "thumbhash":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.Thumbhash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbhash\"")
			}
		case "type":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "unassignedFaces":
			if err := func() error {
				s.UnassignedFaces = make([]AssetFaceWithoutPersonResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetFaceWithoutPersonResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UnassignedFaces = append(s.UnassignedFaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unassignedFaces\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "visibility":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b10101111,
		0b01111111,
		0b01010110,
		0b11011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetResponseDto) {
					name = jsonFieldsNameOfAssetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetStackResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetStackResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetCount")
		e.Int(s.AssetCount)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("primaryAssetId")
		e.Str(s.PrimaryAssetId)
	}
}

var jsonFieldsNameOfAssetStackResponseDto = [3]string{
	0: "assetCount",
	1: "id",
	2: "primaryAssetId",
}

// Decode decodes AssetStackResponseDto from json.
func (s *AssetStackResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetStackResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AssetCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetCount\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "primaryAssetId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PrimaryAssetId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryAssetId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetStackResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetStackResponseDto) {
					name = jsonFieldsNameOfAssetStackResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetStackResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetStackResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssetStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssetStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("images")
		e.Int(s.Images)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("videos")
		e.Int(s.Videos)
	}
}

var jsonFieldsNameOfAssetStatsResponseDto = [3]string{
	0: "images",
	1: "total",
	2: "videos",
}

// Decode decodes AssetStatsResponseDto from json.
func (s *AssetStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "images":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Images = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"images\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "videos":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Videos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssetStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAssetStatsResponseDto) {
					name = jsonFieldsNameOfAssetStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssetStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetTypeEnum as json.
func (s AssetTypeEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetTypeEnum from json.
func (s *AssetTypeEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetTypeEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetTypeEnum(v) {
	case AssetTypeEnumIMAGE:
		*s = AssetTypeEnumIMAGE
	case AssetTypeEnumVIDEO:
		*s = AssetTypeEnumVIDEO
	case AssetTypeEnumAUDIO:
		*s = AssetTypeEnumAUDIO
	case AssetTypeEnumOTHER:
		*s = AssetTypeEnumOTHER
	default:
		*s = AssetTypeEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetVisibility as json.
func (s AssetVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssetVisibility from json.
func (s *AssetVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssetVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssetVisibility(v) {
	case AssetVisibilityArchive:
		*s = AssetVisibilityArchive
	case AssetVisibilityTimeline:
		*s = AssetVisibilityTimeline
	case AssetVisibilityHidden:
		*s = AssetVisibilityHidden
	case AssetVisibilityLocked:
		*s = AssetVisibilityLocked
	default:
		*s = AssetVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssetVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssetVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AudioCodec as json.
func (s AudioCodec) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AudioCodec from json.
func (s *AudioCodec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioCodec to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AudioCodec(v) {
	case AudioCodecMp3:
		*s = AudioCodecMp3
	case AudioCodecAac:
		*s = AudioCodecAac
	case AudioCodecLibopus:
		*s = AudioCodecLibopus
	case AudioCodecPcmS16le:
		*s = AudioCodecPcmS16le
	default:
		*s = AudioCodec(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AudioCodec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioCodec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expiresAt")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		e.FieldStart("isElevated")
		e.Bool(s.IsElevated)
	}
	{
		e.FieldStart("password")
		e.Bool(s.Password)
	}
	{
		e.FieldStart("pinCode")
		e.Bool(s.PinCode)
	}
	{
		if s.PinExpiresAt.Set {
			e.FieldStart("pinExpiresAt")
			s.PinExpiresAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthStatusResponseDto = [5]string{
	0: "expiresAt",
	1: "isElevated",
	2: "password",
	3: "pinCode",
	4: "pinExpiresAt",
}

// Decode decodes AuthStatusResponseDto from json.
func (s *AuthStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expiresAt":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isElevated":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsElevated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isElevated\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Password = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "pinCode":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.PinCode = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinCode\"")
			}
		case "pinExpiresAt":
			if err := func() error {
				s.PinExpiresAt.Reset()
				if err := s.PinExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinExpiresAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthStatusResponseDto) {
					name = jsonFieldsNameOfAuthStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvatarUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvatarUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
}

var jsonFieldsNameOfAvatarUpdate = [1]string{
	0: "color",
}

// Decode decodes AvatarUpdate from json.
func (s *AvatarUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvatarUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvatarUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvatarUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvatarUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkIdErrorReason as json.
func (s BulkIdErrorReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkIdErrorReason from json.
func (s *BulkIdErrorReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkIdErrorReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkIdErrorReason(v) {
	case BulkIdErrorReasonDuplicate:
		*s = BulkIdErrorReasonDuplicate
	case BulkIdErrorReasonNoPermission:
		*s = BulkIdErrorReasonNoPermission
	case BulkIdErrorReasonNotFound:
		*s = BulkIdErrorReasonNotFound
	case BulkIdErrorReasonUnknown:
		*s = BulkIdErrorReasonUnknown
	default:
		*s = BulkIdErrorReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkIdErrorReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkIdErrorReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkIdResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkIdResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfBulkIdResponseDto = [3]string{
	0: "error",
	1: "id",
	2: "success",
}

// Decode decodes BulkIdResponseDto from json.
func (s *BulkIdResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkIdResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkIdResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkIdResponseDto) {
					name = jsonFieldsNameOfBulkIdResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkIdResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkIdResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkIdResponseDtoError as json.
func (s BulkIdResponseDtoError) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkIdResponseDtoError from json.
func (s *BulkIdResponseDtoError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkIdResponseDtoError to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkIdResponseDtoError(v) {
	case BulkIdResponseDtoErrorDuplicate:
		*s = BulkIdResponseDtoErrorDuplicate
	case BulkIdResponseDtoErrorNoPermission:
		*s = BulkIdResponseDtoErrorNoPermission
	case BulkIdResponseDtoErrorNotFound:
		*s = BulkIdResponseDtoErrorNotFound
	case BulkIdResponseDtoErrorUnknown:
		*s = BulkIdResponseDtoErrorUnknown
	default:
		*s = BulkIdResponseDtoError(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkIdResponseDtoError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkIdResponseDtoError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkIdsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkIdsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkIdsDto = [1]string{
	0: "ids",
}

// Decode decodes BulkIdsDto from json.
func (s *BulkIdsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkIdsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkIdsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkIdsDto) {
					name = jsonFieldsNameOfBulkIdsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkIdsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkIdsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CLIPConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CLIPConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("modelName")
		e.Str(s.ModelName)
	}
}

var jsonFieldsNameOfCLIPConfig = [2]string{
	0: "enabled",
	1: "modelName",
}

// Decode decodes CLIPConfig from json.
func (s *CLIPConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CLIPConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "modelName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modelName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CLIPConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCLIPConfig) {
					name = jsonFieldsNameOfCLIPConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CLIPConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CLIPConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CQMode as json.
func (s CQMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CQMode from json.
func (s *CQMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CQMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CQMode(v) {
	case CQModeAuto:
		*s = CQModeAuto
	case CQModeCqp:
		*s = CQModeCqp
	case CQModeIcq:
		*s = CQModeIcq
	default:
		*s = CQMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CQMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CQMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CastResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CastResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gCastEnabled")
		e.Bool(s.GCastEnabled)
	}
}

var jsonFieldsNameOfCastResponse = [1]string{
	0: "gCastEnabled",
}

// Decode decodes CastResponse from json.
func (s *CastResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CastResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gCastEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.GCastEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gCastEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CastResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCastResponse) {
					name = jsonFieldsNameOfCastResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CastResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CastResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CastUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CastUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.GCastEnabled.Set {
			e.FieldStart("gCastEnabled")
			s.GCastEnabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfCastUpdate = [1]string{
	0: "gCastEnabled",
}

// Decode decodes CastUpdate from json.
func (s *CastUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CastUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gCastEnabled":
			if err := func() error {
				s.GCastEnabled.Reset()
				if err := s.GCastEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gCastEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CastUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CastUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CastUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChangePasswordDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChangePasswordDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("newPassword")
		e.Str(s.NewPassword)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfChangePasswordDto = [2]string{
	0: "newPassword",
	1: "password",
}

// Decode decodes ChangePasswordDto from json.
func (s *ChangePasswordDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePasswordDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "newPassword":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newPassword\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChangePasswordDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChangePasswordDto) {
					name = jsonFieldsNameOfChangePasswordDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePasswordDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePasswordDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckExistingAssetsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckExistingAssetsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("deviceAssetIds")
		e.ArrStart()
		for _, elem := range s.DeviceAssetIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("deviceId")
		e.Str(s.DeviceId)
	}
}

var jsonFieldsNameOfCheckExistingAssetsDto = [2]string{
	0: "deviceAssetIds",
	1: "deviceId",
}

// Decode decodes CheckExistingAssetsDto from json.
func (s *CheckExistingAssetsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckExistingAssetsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deviceAssetIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DeviceAssetIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DeviceAssetIds = append(s.DeviceAssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceAssetIds\"")
			}
		case "deviceId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DeviceId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckExistingAssetsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckExistingAssetsDto) {
					name = jsonFieldsNameOfCheckExistingAssetsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckExistingAssetsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckExistingAssetsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckExistingAssetsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckExistingAssetsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("existingIds")
		e.ArrStart()
		for _, elem := range s.ExistingIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCheckExistingAssetsResponseDto = [1]string{
	0: "existingIds",
}

// Decode decodes CheckExistingAssetsResponseDto from json.
func (s *CheckExistingAssetsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckExistingAssetsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "existingIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ExistingIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExistingIds = append(s.ExistingIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"existingIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckExistingAssetsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckExistingAssetsResponseDto) {
					name = jsonFieldsNameOfCheckExistingAssetsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckExistingAssetsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckExistingAssetsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Colorspace as json.
func (s Colorspace) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Colorspace from json.
func (s *Colorspace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Colorspace to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Colorspace(v) {
	case ColorspaceSrgb:
		*s = ColorspaceSrgb
	case ColorspaceP3:
		*s = ColorspaceP3
	default:
		*s = Colorspace(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Colorspace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Colorspace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContributorCountResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContributorCountResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetCount")
		e.Int(s.AssetCount)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
}

var jsonFieldsNameOfContributorCountResponseDto = [2]string{
	0: "assetCount",
	1: "userId",
}

// Decode decodes ContributorCountResponseDto from json.
func (s *ContributorCountResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContributorCountResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AssetCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetCount\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContributorCountResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContributorCountResponseDto) {
					name = jsonFieldsNameOfContributorCountResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContributorCountResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContributorCountResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAlbumDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAlbumDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumName")
		e.Str(s.AlbumName)
	}
	{
		if s.AlbumUsers != nil {
			e.FieldStart("albumUsers")
			e.ArrStart()
			for _, elem := range s.AlbumUsers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AssetIds != nil {
			e.FieldStart("assetIds")
			e.ArrStart()
			for _, elem := range s.AssetIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateAlbumDto = [4]string{
	0: "albumName",
	1: "albumUsers",
	2: "assetIds",
	3: "description",
}

// Decode decodes CreateAlbumDto from json.
func (s *CreateAlbumDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAlbumDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AlbumName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumName\"")
			}
		case "albumUsers":
			if err := func() error {
				s.AlbumUsers = make([]AlbumUserCreateDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlbumUserCreateDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlbumUsers = append(s.AlbumUsers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumUsers\"")
			}
		case "assetIds":
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAlbumDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAlbumDto) {
					name = jsonFieldsNameOfCreateAlbumDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAlbumDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAlbumDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateLibraryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateLibraryDto) encodeFields(e *jx.Encoder) {
	{
		if s.ExclusionPatterns != nil {
			e.FieldStart("exclusionPatterns")
			e.ArrStart()
			for _, elem := range s.ExclusionPatterns {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportPaths != nil {
			e.FieldStart("importPaths")
			e.ArrStart()
			for _, elem := range s.ImportPaths {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("ownerId")
		json.EncodeUUID(e, s.OwnerId)
	}
}

var jsonFieldsNameOfCreateLibraryDto = [4]string{
	0: "exclusionPatterns",
	1: "importPaths",
	2: "name",
	3: "ownerId",
}

// Decode decodes CreateLibraryDto from json.
func (s *CreateLibraryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLibraryDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exclusionPatterns":
			if err := func() error {
				s.ExclusionPatterns = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExclusionPatterns = append(s.ExclusionPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusionPatterns\"")
			}
		case "importPaths":
			if err := func() error {
				s.ImportPaths = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ImportPaths = append(s.ImportPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPaths\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ownerId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.OwnerId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateLibraryDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateLibraryDto) {
					name = jsonFieldsNameOfCreateLibraryDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLibraryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLibraryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateProfileImageResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateProfileImageResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("profileChangedAt")
		json.EncodeDateTime(e, s.ProfileChangedAt)
	}
	{
		e.FieldStart("profileImagePath")
		e.Str(s.ProfileImagePath)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
}

var jsonFieldsNameOfCreateProfileImageResponseDto = [3]string{
	0: "profileChangedAt",
	1: "profileImagePath",
	2: "userId",
}

// Decode decodes CreateProfileImageResponseDto from json.
func (s *CreateProfileImageResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProfileImageResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileChangedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ProfileChangedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileChangedAt\"")
			}
		case "profileImagePath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileImagePath\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateProfileImageResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateProfileImageResponseDto) {
					name = jsonFieldsNameOfCreateProfileImageResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProfileImageResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProfileImageResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseBackupConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseBackupConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cronExpression")
		e.Str(s.CronExpression)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("keepLastAmount")
		e.Float64(s.KeepLastAmount)
	}
}

var jsonFieldsNameOfDatabaseBackupConfig = [3]string{
	0: "cronExpression",
	1: "enabled",
	2: "keepLastAmount",
}

// Decode decodes DatabaseBackupConfig from json.
func (s *DatabaseBackupConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseBackupConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cronExpression":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CronExpression = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cronExpression\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "keepLastAmount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.KeepLastAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keepLastAmount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseBackupConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseBackupConfig) {
					name = jsonFieldsNameOfDatabaseBackupConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseBackupConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseBackupConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DownloadArchiveInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DownloadArchiveInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetIds")
		e.ArrStart()
		for _, elem := range s.AssetIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
}

var jsonFieldsNameOfDownloadArchiveInfo = [2]string{
	0: "assetIds",
	1: "size",
}

// Decode decodes DownloadArchiveInfo from json.
func (s *DownloadArchiveInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadArchiveInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AssetIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DownloadArchiveInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDownloadArchiveInfo) {
					name = jsonFieldsNameOfDownloadArchiveInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadArchiveInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadArchiveInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DownloadInfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DownloadInfoDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumId.Set {
			e.FieldStart("albumId")
			s.AlbumId.Encode(e)
		}
	}
	{
		if s.ArchiveSize.Set {
			e.FieldStart("archiveSize")
			s.ArchiveSize.Encode(e)
		}
	}
	{
		if s.AssetIds != nil {
			e.FieldStart("assetIds")
			e.ArrStart()
			for _, elem := range s.AssetIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UserId.Set {
			e.FieldStart("userId")
			s.UserId.Encode(e)
		}
	}
}

var jsonFieldsNameOfDownloadInfoDto = [4]string{
	0: "albumId",
	1: "archiveSize",
	2: "assetIds",
	3: "userId",
}

// Decode decodes DownloadInfoDto from json.
func (s *DownloadInfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadInfoDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumId":
			if err := func() error {
				s.AlbumId.Reset()
				if err := s.AlbumId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumId\"")
			}
		case "archiveSize":
			if err := func() error {
				s.ArchiveSize.Reset()
				if err := s.ArchiveSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archiveSize\"")
			}
		case "assetIds":
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "userId":
			if err := func() error {
				s.UserId.Reset()
				if err := s.UserId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DownloadInfoDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadInfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadInfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DownloadResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DownloadResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("archiveSize")
		e.Int(s.ArchiveSize)
	}
	{
		e.FieldStart("includeEmbeddedVideos")
		e.Bool(s.IncludeEmbeddedVideos)
	}
}

var jsonFieldsNameOfDownloadResponse = [2]string{
	0: "archiveSize",
	1: "includeEmbeddedVideos",
}

// Decode decodes DownloadResponse from json.
func (s *DownloadResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archiveSize":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ArchiveSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archiveSize\"")
			}
		case "includeEmbeddedVideos":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncludeEmbeddedVideos = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeEmbeddedVideos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DownloadResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDownloadResponse) {
					name = jsonFieldsNameOfDownloadResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DownloadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DownloadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("archives")
		e.ArrStart()
		for _, elem := range s.Archives {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalSize")
		e.Int(s.TotalSize)
	}
}

var jsonFieldsNameOfDownloadResponseDto = [2]string{
	0: "archives",
	1: "totalSize",
}

// Decode decodes DownloadResponseDto from json.
func (s *DownloadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archives":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Archives = make([]DownloadArchiveInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DownloadArchiveInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Archives = append(s.Archives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archives\"")
			}
		case "totalSize":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSize\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DownloadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDownloadResponseDto) {
					name = jsonFieldsNameOfDownloadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DownloadUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DownloadUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.ArchiveSize.Set {
			e.FieldStart("archiveSize")
			s.ArchiveSize.Encode(e)
		}
	}
	{
		if s.IncludeEmbeddedVideos.Set {
			e.FieldStart("includeEmbeddedVideos")
			s.IncludeEmbeddedVideos.Encode(e)
		}
	}
}

var jsonFieldsNameOfDownloadUpdate = [2]string{
	0: "archiveSize",
	1: "includeEmbeddedVideos",
}

// Decode decodes DownloadUpdate from json.
func (s *DownloadUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archiveSize":
			if err := func() error {
				s.ArchiveSize.Reset()
				if err := s.ArchiveSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archiveSize\"")
			}
		case "includeEmbeddedVideos":
			if err := func() error {
				s.IncludeEmbeddedVideos.Reset()
				if err := s.IncludeEmbeddedVideos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeEmbeddedVideos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DownloadUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DuplicateDetectionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DuplicateDetectionConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("maxDistance")
		e.Float64(s.MaxDistance)
	}
}

var jsonFieldsNameOfDuplicateDetectionConfig = [2]string{
	0: "enabled",
	1: "maxDistance",
}

// Decode decodes DuplicateDetectionConfig from json.
func (s *DuplicateDetectionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DuplicateDetectionConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "maxDistance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.MaxDistance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxDistance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DuplicateDetectionConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDuplicateDetectionConfig) {
					name = jsonFieldsNameOfDuplicateDetectionConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DuplicateDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DuplicateDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DuplicateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DuplicateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("duplicateId")
		e.Str(s.DuplicateId)
	}
}

var jsonFieldsNameOfDuplicateResponseDto = [2]string{
	0: "assets",
	1: "duplicateId",
}

// Decode decodes DuplicateResponseDto from json.
func (s *DuplicateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DuplicateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Assets = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "duplicateId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DuplicateId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DuplicateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDuplicateResponseDto) {
					name = jsonFieldsNameOfDuplicateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DuplicateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DuplicateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EmailNotificationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EmailNotificationsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumInvite")
		e.Bool(s.AlbumInvite)
	}
	{
		e.FieldStart("albumUpdate")
		e.Bool(s.AlbumUpdate)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfEmailNotificationsResponse = [3]string{
	0: "albumInvite",
	1: "albumUpdate",
	2: "enabled",
}

// Decode decodes EmailNotificationsResponse from json.
func (s *EmailNotificationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmailNotificationsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumInvite":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AlbumInvite = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumInvite\"")
			}
		case "albumUpdate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.AlbumUpdate = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumUpdate\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmailNotificationsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEmailNotificationsResponse) {
					name = jsonFieldsNameOfEmailNotificationsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EmailNotificationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmailNotificationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EmailNotificationsUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EmailNotificationsUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumInvite.Set {
			e.FieldStart("albumInvite")
			s.AlbumInvite.Encode(e)
		}
	}
	{
		if s.AlbumUpdate.Set {
			e.FieldStart("albumUpdate")
			s.AlbumUpdate.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfEmailNotificationsUpdate = [3]string{
	0: "albumInvite",
	1: "albumUpdate",
	2: "enabled",
}

// Decode decodes EmailNotificationsUpdate from json.
func (s *EmailNotificationsUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmailNotificationsUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumInvite":
			if err := func() error {
				s.AlbumInvite.Reset()
				if err := s.AlbumInvite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumInvite\"")
			}
		case "albumUpdate":
			if err := func() error {
				s.AlbumUpdate.Reset()
				if err := s.AlbumUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumUpdate\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmailNotificationsUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EmailNotificationsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmailNotificationsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExifResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExifResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.City.Set {
			e.FieldStart("city")
			s.City.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.DateTimeOriginal.Set {
			e.FieldStart("dateTimeOriginal")
			s.DateTimeOriginal.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExifImageHeight.Set {
			e.FieldStart("exifImageHeight")
			s.ExifImageHeight.Encode(e)
		}
	}
	{
		if s.ExifImageWidth.Set {
			e.FieldStart("exifImageWidth")
			s.ExifImageWidth.Encode(e)
		}
	}
	{
		if s.ExposureTime.Set {
			e.FieldStart("exposureTime")
			s.ExposureTime.Encode(e)
		}
	}
	{
		if s.FNumber.Set {
			e.FieldStart("fNumber")
			s.FNumber.Encode(e)
		}
	}
	{
		if s.FileSizeInByte.Set {
			e.FieldStart("fileSizeInByte")
			s.FileSizeInByte.Encode(e)
		}
	}
	{
		if s.FocalLength.Set {
			e.FieldStart("focalLength")
			s.FocalLength.Encode(e)
		}
	}
	{
		if s.Iso.Set {
			e.FieldStart("iso")
			s.Iso.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.LensModel.Set {
			e.FieldStart("lensModel")
			s.LensModel.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.Make.Set {
			e.FieldStart("make")
			s.Make.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.ModifyDate.Set {
			e.FieldStart("modifyDate")
			s.ModifyDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Orientation.Set {
			e.FieldStart("orientation")
			s.Orientation.Encode(e)
		}
	}
	{
		if s.ProjectionType.Set {
			e.FieldStart("projectionType")
			s.ProjectionType.Encode(e)
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TimeZone.Set {
			e.FieldStart("timeZone")
			s.TimeZone.Encode(e)
		}
	}
}

var jsonFieldsNameOfExifResponseDto = [22]string{
	0:  "city",
	1:  "country",
	2:  "dateTimeOriginal",
	3:  "description",
	4:  "exifImageHeight",
	5:  "exifImageWidth",
	6:  "exposureTime",
	7:  "fNumber",
	8:  "fileSizeInByte",
	9:  "focalLength",
	10: "iso",
	11: "latitude",
	12: "lensModel",
	13: "longitude",
	14: "make",
	15: "model",
	16: "modifyDate",
	17: "orientation",
	18: "projectionType",
	19: "rating",
	20: "state",
	21: "timeZone",
}

// Decode decodes ExifResponseDto from json.
func (s *ExifResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExifResponseDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "city":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "dateTimeOriginal":
			if err := func() error {
				s.DateTimeOriginal.Reset()
				if err := s.DateTimeOriginal.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTimeOriginal\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "exifImageHeight":
			if err := func() error {
				s.ExifImageHeight.Reset()
				if err := s.ExifImageHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exifImageHeight\"")
			}
		case "exifImageWidth":
			if err := func() error {
				s.ExifImageWidth.Reset()
				if err := s.ExifImageWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exifImageWidth\"")
			}
		case "exposureTime":
			if err := func() error {
				s.ExposureTime.Reset()
				if err := s.ExposureTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exposureTime\"")
			}
		case "fNumber":
			if err := func() error {
				s.FNumber.Reset()
				if err := s.FNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fNumber\"")
			}
		case "fileSizeInByte":
			if err := func() error {
				s.FileSizeInByte.Reset()
				if err := s.FileSizeInByte.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileSizeInByte\"")
			}
		case "focalLength":
			if err := func() error {
				s.FocalLength.Reset()
				if err := s.FocalLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"focalLength\"")
			}
		case "iso":
			if err := func() error {
				s.Iso.Reset()
				if err := s.Iso.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iso\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "lensModel":
			if err := func() error {
				s.LensModel.Reset()
				if err := s.LensModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lensModel\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "make":
			if err := func() error {
				s.Make.Reset()
				if err := s.Make.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"make\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "modifyDate":
			if err := func() error {
				s.ModifyDate.Reset()
				if err := s.ModifyDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifyDate\"")
			}
		case "orientation":
			if err := func() error {
				s.Orientation.Reset()
				if err := s.Orientation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orientation\"")
			}
		case "projectionType":
			if err := func() error {
				s.ProjectionType.Reset()
				if err := s.ProjectionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectionType\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "timeZone":
			if err := func() error {
				s.TimeZone.Reset()
				if err := s.TimeZone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeZone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExifResponseDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExifResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExifResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FaceDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FaceDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfFaceDto = [1]string{
	0: "id",
}

// Decode decodes FaceDto from json.
func (s *FaceDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceDto) {
					name = jsonFieldsNameOfFaceDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FaceDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FacialRecognitionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FacialRecognitionConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("maxDistance")
		e.Float64(s.MaxDistance)
	}
	{
		e.FieldStart("minFaces")
		e.Int(s.MinFaces)
	}
	{
		e.FieldStart("minScore")
		e.Float64(s.MinScore)
	}
	{
		e.FieldStart("modelName")
		e.Str(s.ModelName)
	}
}

var jsonFieldsNameOfFacialRecognitionConfig = [5]string{
	0: "enabled",
	1: "maxDistance",
	2: "minFaces",
	3: "minScore",
	4: "modelName",
}

// Decode decodes FacialRecognitionConfig from json.
func (s *FacialRecognitionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FacialRecognitionConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "maxDistance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.MaxDistance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxDistance\"")
			}
		case "minFaces":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MinFaces = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minFaces\"")
			}
		case "minScore":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.MinScore = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minScore\"")
			}
		case "modelName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ModelName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modelName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FacialRecognitionConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFacialRecognitionConfig) {
					name = jsonFieldsNameOfFacialRecognitionConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FacialRecognitionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FacialRecognitionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FoldersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FoldersResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("sidebarWeb")
		e.Bool(s.SidebarWeb)
	}
}

var jsonFieldsNameOfFoldersResponse = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes FoldersResponse from json.
func (s *FoldersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FoldersResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SidebarWeb = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FoldersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFoldersResponse) {
					name = jsonFieldsNameOfFoldersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FoldersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FoldersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FoldersUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FoldersUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.SidebarWeb.Set {
			e.FieldStart("sidebarWeb")
			s.SidebarWeb.Encode(e)
		}
	}
}

var jsonFieldsNameOfFoldersUpdate = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes FoldersUpdate from json.
func (s *FoldersUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FoldersUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			if err := func() error {
				s.SidebarWeb.Reset()
				if err := s.SidebarWeb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FoldersUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FoldersUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FoldersUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImageFormat as json.
func (s ImageFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ImageFormat from json.
func (s *ImageFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImageFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ImageFormat(v) {
	case ImageFormatJpeg:
		*s = ImageFormatJpeg
	case ImageFormatWEBP:
		*s = ImageFormatWEBP
	default:
		*s = ImageFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ImageFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImageFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JobCommand as json.
func (s JobCommand) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JobCommand from json.
func (s *JobCommand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobCommand to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobCommand(v) {
	case JobCommandStart:
		*s = JobCommandStart
	case JobCommandPause:
		*s = JobCommandPause
	case JobCommandResume:
		*s = JobCommandResume
	case JobCommandEmpty:
		*s = JobCommandEmpty
	case JobCommandClearFailed:
		*s = JobCommandClearFailed
	default:
		*s = JobCommand(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JobCommand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobCommand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobCommandDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobCommandDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("command")
		s.Command.Encode(e)
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfJobCommandDto = [2]string{
	0: "command",
	1: "force",
}

// Decode decodes JobCommandDto from json.
func (s *JobCommandDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobCommandDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Command.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobCommandDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobCommandDto) {
					name = jsonFieldsNameOfJobCommandDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobCommandDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobCommandDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobCountsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobCountsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("active")
		e.Int(s.Active)
	}
	{
		e.FieldStart("completed")
		e.Int(s.Completed)
	}
	{
		e.FieldStart("delayed")
		e.Int(s.Delayed)
	}
	{
		e.FieldStart("failed")
		e.Int(s.Failed)
	}
	{
		e.FieldStart("paused")
		e.Int(s.Paused)
	}
	{
		e.FieldStart("waiting")
		e.Int(s.Waiting)
	}
}

var jsonFieldsNameOfJobCountsDto = [6]string{
	0: "active",
	1: "completed",
	2: "delayed",
	3: "failed",
	4: "paused",
	5: "waiting",
}

// Decode decodes JobCountsDto from json.
func (s *JobCountsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobCountsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Active = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "completed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Completed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		case "delayed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Delayed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delayed\"")
			}
		case "failed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Failed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed\"")
			}
		case "paused":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Paused = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "waiting":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Waiting = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"waiting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobCountsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobCountsDto) {
					name = jsonFieldsNameOfJobCountsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobCountsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobCountsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobCreateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
}

var jsonFieldsNameOfJobCreateDto = [1]string{
	0: "name",
}

// Decode decodes JobCreateDto from json.
func (s *JobCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobCreateDto) {
					name = jsonFieldsNameOfJobCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobSettingsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobSettingsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("concurrency")
		e.Int(s.Concurrency)
	}
}

var jsonFieldsNameOfJobSettingsDto = [1]string{
	0: "concurrency",
}

// Decode decodes JobSettingsDto from json.
func (s *JobSettingsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobSettingsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Concurrency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobSettingsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobSettingsDto) {
					name = jsonFieldsNameOfJobSettingsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobSettingsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobSettingsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobStatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobStatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("jobCounts")
		s.JobCounts.Encode(e)
	}
	{
		e.FieldStart("queueStatus")
		s.QueueStatus.Encode(e)
	}
}

var jsonFieldsNameOfJobStatusDto = [2]string{
	0: "jobCounts",
	1: "queueStatus",
}

// Decode decodes JobStatusDto from json.
func (s *JobStatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStatusDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "jobCounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.JobCounts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobCounts\"")
			}
		case "queueStatus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.QueueStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobStatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobStatusDto) {
					name = jsonFieldsNameOfJobStatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobStatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobStatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LibraryResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LibraryResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetCount")
		e.Int(s.AssetCount)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("exclusionPatterns")
		e.ArrStart()
		for _, elem := range s.ExclusionPatterns {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("importPaths")
		e.ArrStart()
		for _, elem := range s.ImportPaths {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("ownerId")
		e.Str(s.OwnerId)
	}
	{
		e.FieldStart("refreshedAt")
		s.RefreshedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfLibraryResponseDto = [9]string{
	0: "assetCount",
	1: "createdAt",
	2: "exclusionPatterns",
	3: "id",
	4: "importPaths",
	5: "name",
	6: "ownerId",
	7: "refreshedAt",
	8: "updatedAt",
}

// Decode decodes LibraryResponseDto from json.
func (s *LibraryResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LibraryResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AssetCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetCount\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "exclusionPatterns":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ExclusionPatterns = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExclusionPatterns = append(s.ExclusionPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusionPatterns\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "importPaths":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.ImportPaths = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ImportPaths = append(s.ImportPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPaths\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ownerId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.OwnerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		case "refreshedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.RefreshedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshedAt\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LibraryResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLibraryResponseDto) {
					name = jsonFieldsNameOfLibraryResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LibraryResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LibraryResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LibraryStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LibraryStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("photos")
		e.Int(s.Photos)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("usage")
		e.Int64(s.Usage)
	}
	{
		e.FieldStart("videos")
		e.Int(s.Videos)
	}
}

var jsonFieldsNameOfLibraryStatsResponseDto = [4]string{
	0: "photos",
	1: "total",
	2: "usage",
	3: "videos",
}

// Decode decodes LibraryStatsResponseDto from json.
func (s *LibraryStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LibraryStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "photos":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Photos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photos\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Usage = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "videos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Videos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LibraryStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLibraryStatsResponseDto) {
					name = jsonFieldsNameOfLibraryStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LibraryStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LibraryStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseKeyDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseKeyDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activationKey")
		e.Str(s.ActivationKey)
	}
	{
		e.FieldStart("licenseKey")
		e.Str(s.LicenseKey)
	}
}

var jsonFieldsNameOfLicenseKeyDto = [2]string{
	0: "activationKey",
	1: "licenseKey",
}

// Decode decodes LicenseKeyDto from json.
func (s *LicenseKeyDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseKeyDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activationKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ActivationKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activationKey\"")
			}
		case "licenseKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LicenseKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseKeyDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseKeyDto) {
					name = jsonFieldsNameOfLicenseKeyDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseKeyDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseKeyDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activatedAt")
		json.EncodeDateTime(e, s.ActivatedAt)
	}
	{
		e.FieldStart("activationKey")
		e.Str(s.ActivationKey)
	}
	{
		e.FieldStart("licenseKey")
		e.Str(s.LicenseKey)
	}
}

var jsonFieldsNameOfLicenseResponseDto = [3]string{
	0: "activatedAt",
	1: "activationKey",
	2: "licenseKey",
}

// Decode decodes LicenseResponseDto from json.
func (s *LicenseResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activatedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ActivatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activatedAt\"")
			}
		case "activationKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ActivationKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activationKey\"")
			}
		case "licenseKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LicenseKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseResponseDto) {
					name = jsonFieldsNameOfLicenseResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogLevel as json.
func (s LogLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LogLevel from json.
func (s *LogLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LogLevel(v) {
	case LogLevelVerbose:
		*s = LogLevelVerbose
	case LogLevelDebug:
		*s = LogLevelDebug
	case LogLevelLog:
		*s = LogLevelLog
	case LogLevelWarn:
		*s = LogLevelWarn
	case LogLevelError:
		*s = LogLevelError
	case LogLevelFatal:
		*s = LogLevelFatal
	default:
		*s = LogLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginCredentialDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginCredentialDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLoginCredentialDto = [2]string{
	0: "email",
	1: "password",
}

// Decode decodes LoginCredentialDto from json.
func (s *LoginCredentialDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginCredentialDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginCredentialDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginCredentialDto) {
					name = jsonFieldsNameOfLoginCredentialDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginCredentialDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginCredentialDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
	{
		e.FieldStart("isAdmin")
		e.Bool(s.IsAdmin)
	}
	{
		e.FieldStart("isOnboarded")
		e.Bool(s.IsOnboarded)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("profileImagePath")
		e.Str(s.ProfileImagePath)
	}
	{
		e.FieldStart("shouldChangePassword")
		e.Bool(s.ShouldChangePassword)
	}
	{
		e.FieldStart("userEmail")
		e.Str(s.UserEmail)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
}

var jsonFieldsNameOfLoginResponseDto = [8]string{
	0: "accessToken",
	1: "isAdmin",
	2: "isOnboarded",
	3: "name",
	4: "profileImagePath",
	5: "shouldChangePassword",
	6: "userEmail",
	7: "userId",
}

// Decode decodes LoginResponseDto from json.
func (s *LoginResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		case "isAdmin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAdmin\"")
			}
		case "isOnboarded":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboarded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOnboarded\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "profileImagePath":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProfileImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileImagePath\"")
			}
		case "shouldChangePassword":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ShouldChangePassword = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shouldChangePassword\"")
			}
		case "userEmail":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserEmail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userEmail\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginResponseDto) {
					name = jsonFieldsNameOfLoginResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LogoutResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LogoutResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("redirectUri")
		e.Str(s.RedirectUri)
	}
	{
		e.FieldStart("successful")
		e.Bool(s.Successful)
	}
}

var jsonFieldsNameOfLogoutResponseDto = [2]string{
	0: "redirectUri",
	1: "successful",
}

// Decode decodes LogoutResponseDto from json.
func (s *LogoutResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogoutResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "redirectUri":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RedirectUri = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redirectUri\"")
			}
		case "successful":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Successful = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogoutResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogoutResponseDto) {
					name = jsonFieldsNameOfLogoutResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LogoutResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogoutResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MachineLearningAvailabilityChecksDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MachineLearningAvailabilityChecksDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("interval")
		e.Float64(s.Interval)
	}
	{
		e.FieldStart("timeout")
		e.Float64(s.Timeout)
	}
}

var jsonFieldsNameOfMachineLearningAvailabilityChecksDto = [3]string{
	0: "enabled",
	1: "interval",
	2: "timeout",
}

// Decode decodes MachineLearningAvailabilityChecksDto from json.
func (s *MachineLearningAvailabilityChecksDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MachineLearningAvailabilityChecksDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "interval":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Interval = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "timeout":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Timeout = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MachineLearningAvailabilityChecksDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMachineLearningAvailabilityChecksDto) {
					name = jsonFieldsNameOfMachineLearningAvailabilityChecksDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MachineLearningAvailabilityChecksDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MachineLearningAvailabilityChecksDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManualJobName as json.
func (s ManualJobName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ManualJobName from json.
func (s *ManualJobName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManualJobName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ManualJobName(v) {
	case ManualJobNamePersonCleanup:
		*s = ManualJobNamePersonCleanup
	case ManualJobNameTagCleanup:
		*s = ManualJobNameTagCleanup
	case ManualJobNameUserCleanup:
		*s = ManualJobNameUserCleanup
	case ManualJobNameMemoryCleanup:
		*s = ManualJobNameMemoryCleanup
	case ManualJobNameMemoryCreate:
		*s = ManualJobNameMemoryCreate
	case ManualJobNameBackupDatabase:
		*s = ManualJobNameBackupDatabase
	default:
		*s = ManualJobName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ManualJobName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManualJobName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapMarkerResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapMarkerResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("city")
		s.City.Encode(e)
	}
	{
		e.FieldStart("country")
		s.Country.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("lat")
		e.Float64(s.Lat)
	}
	{
		e.FieldStart("lon")
		e.Float64(s.Lon)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
}

var jsonFieldsNameOfMapMarkerResponseDto = [6]string{
	0: "city",
	1: "country",
	2: "id",
	3: "lat",
	4: "lon",
	5: "state",
}

// Decode decodes MapMarkerResponseDto from json.
func (s *MapMarkerResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapMarkerResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "city":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "lat":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Lat = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lat\"")
			}
		case "lon":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Lon = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lon\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapMarkerResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapMarkerResponseDto) {
					name = jsonFieldsNameOfMapMarkerResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapMarkerResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapMarkerResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapReverseGeocodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapReverseGeocodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("city")
		s.City.Encode(e)
	}
	{
		e.FieldStart("country")
		s.Country.Encode(e)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
}

var jsonFieldsNameOfMapReverseGeocodeResponseDto = [3]string{
	0: "city",
	1: "country",
	2: "state",
}

// Decode decodes MapReverseGeocodeResponseDto from json.
func (s *MapReverseGeocodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapReverseGeocodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "city":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapReverseGeocodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapReverseGeocodeResponseDto) {
					name = jsonFieldsNameOfMapReverseGeocodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapReverseGeocodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapReverseGeocodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoriesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoriesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfMemoriesResponse = [1]string{
	0: "enabled",
}

// Decode decodes MemoriesResponse from json.
func (s *MemoriesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoriesResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoriesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMemoriesResponse) {
					name = jsonFieldsNameOfMemoriesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoriesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoriesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoriesUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoriesUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfMemoriesUpdate = [1]string{
	0: "enabled",
}

// Decode decodes MemoriesUpdate from json.
func (s *MemoriesUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoriesUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoriesUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoriesUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoriesUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoryCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoryCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.AssetIds != nil {
			e.FieldStart("assetIds")
			e.ArrStart()
			for _, elem := range s.AssetIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.IsSaved.Set {
			e.FieldStart("isSaved")
			s.IsSaved.Encode(e)
		}
	}
	{
		e.FieldStart("memoryAt")
		json.EncodeDateTime(e, s.MemoryAt)
	}
	{
		if s.SeenAt.Set {
			e.FieldStart("seenAt")
			s.SeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfMemoryCreateDto = [6]string{
	0: "assetIds",
	1: "data",
	2: "isSaved",
	3: "memoryAt",
	4: "seenAt",
	5: "type",
}

// Decode decodes MemoryCreateDto from json.
func (s *MemoryCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoryCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetIds":
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "isSaved":
			if err := func() error {
				s.IsSaved.Reset()
				if err := s.IsSaved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSaved\"")
			}
		case "memoryAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.MemoryAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryAt\"")
			}
		case "seenAt":
			if err := func() error {
				s.SeenAt.Reset()
				if err := s.SeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seenAt\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoryCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMemoryCreateDto) {
					name = jsonFieldsNameOfMemoryCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoryCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoryCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoryResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoryResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.HideAt.Set {
			e.FieldStart("hideAt")
			s.HideAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isSaved")
		e.Bool(s.IsSaved)
	}
	{
		e.FieldStart("memoryAt")
		json.EncodeDateTime(e, s.MemoryAt)
	}
	{
		e.FieldStart("ownerId")
		e.Str(s.OwnerId)
	}
	{
		if s.SeenAt.Set {
			e.FieldStart("seenAt")
			s.SeenAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ShowAt.Set {
			e.FieldStart("showAt")
			s.ShowAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfMemoryResponseDto = [13]string{
	0:  "assets",
	1:  "createdAt",
	2:  "data",
	3:  "deletedAt",
	4:  "hideAt",
	5:  "id",
	6:  "isSaved",
	7:  "memoryAt",
	8:  "ownerId",
	9:  "seenAt",
	10: "showAt",
	11: "type",
	12: "updatedAt",
}

// Decode decodes MemoryResponseDto from json.
func (s *MemoryResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoryResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Assets = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "hideAt":
			if err := func() error {
				s.HideAt.Reset()
				if err := s.HideAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hideAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isSaved":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsSaved = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSaved\"")
			}
		case "memoryAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.MemoryAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryAt\"")
			}
		case "ownerId":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OwnerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		case "seenAt":
			if err := func() error {
				s.SeenAt.Reset()
				if err := s.SeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seenAt\"")
			}
		case "showAt":
			if err := func() error {
				s.ShowAt.Reset()
				if err := s.ShowAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"showAt\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoryResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100111,
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMemoryResponseDto) {
					name = jsonFieldsNameOfMemoryResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoryResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoryResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoryStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoryStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfMemoryStatisticsResponseDto = [1]string{
	0: "total",
}

// Decode decodes MemoryStatisticsResponseDto from json.
func (s *MemoryStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoryStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoryStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMemoryStatisticsResponseDto) {
					name = jsonFieldsNameOfMemoryStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoryStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoryStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MemoryType as json.
func (s MemoryType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MemoryType from json.
func (s *MemoryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoryType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MemoryType(v) {
	case MemoryTypeOnThisDay:
		*s = MemoryTypeOnThisDay
	default:
		*s = MemoryType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MemoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MemoryUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MemoryUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.IsSaved.Set {
			e.FieldStart("isSaved")
			s.IsSaved.Encode(e)
		}
	}
	{
		if s.MemoryAt.Set {
			e.FieldStart("memoryAt")
			s.MemoryAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SeenAt.Set {
			e.FieldStart("seenAt")
			s.SeenAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfMemoryUpdateDto = [3]string{
	0: "isSaved",
	1: "memoryAt",
	2: "seenAt",
}

// Decode decodes MemoryUpdateDto from json.
func (s *MemoryUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MemoryUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isSaved":
			if err := func() error {
				s.IsSaved.Reset()
				if err := s.IsSaved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSaved\"")
			}
		case "memoryAt":
			if err := func() error {
				s.MemoryAt.Reset()
				if err := s.MemoryAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryAt\"")
			}
		case "seenAt":
			if err := func() error {
				s.SeenAt.Reset()
				if err := s.SeenAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seenAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MemoryUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MemoryUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MemoryUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MergePersonDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MergePersonDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMergePersonDto = [1]string{
	0: "ids",
}

// Decode decodes MergePersonDto from json.
func (s *MergePersonDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MergePersonDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MergePersonDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMergePersonDto) {
					name = jsonFieldsNameOfMergePersonDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MergePersonDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MergePersonDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetadataSearchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetadataSearchDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumIds != nil {
			e.FieldStart("albumIds")
			e.ArrStart()
			for _, elem := range s.AlbumIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Checksum.Set {
			e.FieldStart("checksum")
			s.Checksum.Encode(e)
		}
	}
	{
		if s.City.Set {
			e.FieldStart("city")
			s.City.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.CreatedAfter.Set {
			e.FieldStart("createdAfter")
			s.CreatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBefore.Set {
			e.FieldStart("createdBefore")
			s.CreatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DeviceAssetId.Set {
			e.FieldStart("deviceAssetId")
			s.DeviceAssetId.Encode(e)
		}
	}
	{
		if s.DeviceId.Set {
			e.FieldStart("deviceId")
			s.DeviceId.Encode(e)
		}
	}
	{
		if s.EncodedVideoPath.Set {
			e.FieldStart("encodedVideoPath")
			s.EncodedVideoPath.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsEncoded.Set {
			e.FieldStart("isEncoded")
			s.IsEncoded.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsMotion.Set {
			e.FieldStart("isMotion")
			s.IsMotion.Encode(e)
		}
	}
	{
		if s.IsNotInAlbum.Set {
			e.FieldStart("isNotInAlbum")
			s.IsNotInAlbum.Encode(e)
		}
	}
	{
		if s.IsOffline.Set {
			e.FieldStart("isOffline")
			s.IsOffline.Encode(e)
		}
	}
	{
		if s.LensModel.Set {
			e.FieldStart("lensModel")
			s.LensModel.Encode(e)
		}
	}
	{
		if s.LibraryId.Set {
			e.FieldStart("libraryId")
			s.LibraryId.Encode(e)
		}
	}
	{
		if s.Make.Set {
			e.FieldStart("make")
			s.Make.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.OriginalFileName.Set {
			e.FieldStart("originalFileName")
			s.OriginalFileName.Encode(e)
		}
	}
	{
		if s.OriginalPath.Set {
			e.FieldStart("originalPath")
			s.OriginalPath.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PersonIds != nil {
			e.FieldStart("personIds")
			e.ArrStart()
			for _, elem := range s.PersonIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PreviewPath.Set {
			e.FieldStart("previewPath")
			s.PreviewPath.Encode(e)
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TagIds.Set {
			e.FieldStart("tagIds")
			s.TagIds.Encode(e)
		}
	}
	{
		if s.TakenAfter.Set {
			e.FieldStart("takenAfter")
			s.TakenAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TakenBefore.Set {
			e.FieldStart("takenBefore")
			s.TakenBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ThumbnailPath.Set {
			e.FieldStart("thumbnailPath")
			s.ThumbnailPath.Encode(e)
		}
	}
	{
		if s.TrashedAfter.Set {
			e.FieldStart("trashedAfter")
			s.TrashedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedBefore.Set {
			e.FieldStart("trashedBefore")
			s.TrashedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.UpdatedAfter.Set {
			e.FieldStart("updatedAfter")
			s.UpdatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBefore.Set {
			e.FieldStart("updatedBefore")
			s.UpdatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.WithDeleted.Set {
			e.FieldStart("withDeleted")
			s.WithDeleted.Encode(e)
		}
	}
	{
		if s.WithExif.Set {
			e.FieldStart("withExif")
			s.WithExif.Encode(e)
		}
	}
	{
		if s.WithPeople.Set {
			e.FieldStart("withPeople")
			s.WithPeople.Encode(e)
		}
	}
	{
		if s.WithStacked.Set {
			e.FieldStart("withStacked")
			s.WithStacked.Encode(e)
		}
	}
}

var jsonFieldsNameOfMetadataSearchDto = [43]string{
	0:  "albumIds",
	1:  "checksum",
	2:  "city",
	3:  "country",
	4:  "createdAfter",
	5:  "createdBefore",
	6:  "description",
	7:  "deviceAssetId",
	8:  "deviceId",
	9:  "encodedVideoPath",
	10: "id",
	11: "isEncoded",
	12: "isFavorite",
	13: "isMotion",
	14: "isNotInAlbum",
	15: "isOffline",
	16: "lensModel",
	17: "libraryId",
	18: "make",
	19: "model",
	20: "order",
	21: "originalFileName",
	22: "originalPath",
	23: "page",
	24: "personIds",
	25: "previewPath",
	26: "rating",
	27: "size",
	28: "state",
	29: "tagIds",
	30: "takenAfter",
	31: "takenBefore",
	32: "thumbnailPath",
	33: "trashedAfter",
	34: "trashedBefore",
	35: "type",
	36: "updatedAfter",
	37: "updatedBefore",
	38: "visibility",
	39: "withDeleted",
	40: "withExif",
	41: "withPeople",
	42: "withStacked",
}

// Decode decodes MetadataSearchDto from json.
func (s *MetadataSearchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetadataSearchDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumIds":
			if err := func() error {
				s.AlbumIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AlbumIds = append(s.AlbumIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumIds\"")
			}
		case "checksum":
			if err := func() error {
				s.Checksum.Reset()
				if err := s.Checksum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checksum\"")
			}
		case "city":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "createdAfter":
			if err := func() error {
				s.CreatedAfter.Reset()
				if err := s.CreatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAfter\"")
			}
		case "createdBefore":
			if err := func() error {
				s.CreatedBefore.Reset()
				if err := s.CreatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBefore\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "deviceAssetId":
			if err := func() error {
				s.DeviceAssetId.Reset()
				if err := s.DeviceAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceAssetId\"")
			}
		case "deviceId":
			if err := func() error {
				s.DeviceId.Reset()
				if err := s.DeviceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceId\"")
			}
		case "encodedVideoPath":
			if err := func() error {
				s.EncodedVideoPath.Reset()
				if err := s.EncodedVideoPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedVideoPath\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isEncoded":
			if err := func() error {
				s.IsEncoded.Reset()
				if err := s.IsEncoded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEncoded\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isMotion":
			if err := func() error {
				s.IsMotion.Reset()
				if err := s.IsMotion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMotion\"")
			}
		case "isNotInAlbum":
			if err := func() error {
				s.IsNotInAlbum.Reset()
				if err := s.IsNotInAlbum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNotInAlbum\"")
			}
		case "isOffline":
			if err := func() error {
				s.IsOffline.Reset()
				if err := s.IsOffline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOffline\"")
			}
		case "lensModel":
			if err := func() error {
				s.LensModel.Reset()
				if err := s.LensModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lensModel\"")
			}
		case "libraryId":
			if err := func() error {
				s.LibraryId.Reset()
				if err := s.LibraryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"libraryId\"")
			}
		case "make":
			if err := func() error {
				s.Make.Reset()
				if err := s.Make.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"make\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "originalFileName":
			if err := func() error {
				s.OriginalFileName.Reset()
				if err := s.OriginalFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalFileName\"")
			}
		case "originalPath":
			if err := func() error {
				s.OriginalPath.Reset()
				if err := s.OriginalPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalPath\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "personIds":
			if err := func() error {
				s.PersonIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PersonIds = append(s.PersonIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personIds\"")
			}
		case "previewPath":
			if err := func() error {
				s.PreviewPath.Reset()
				if err := s.PreviewPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previewPath\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "tagIds":
			if err := func() error {
				s.TagIds.Reset()
				if err := s.TagIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagIds\"")
			}
		case "takenAfter":
			if err := func() error {
				s.TakenAfter.Reset()
				if err := s.TakenAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenAfter\"")
			}
		case "takenBefore":
			if err := func() error {
				s.TakenBefore.Reset()
				if err := s.TakenBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenBefore\"")
			}
		case "thumbnailPath":
			if err := func() error {
				s.ThumbnailPath.Reset()
				if err := s.ThumbnailPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnailPath\"")
			}
		case "trashedAfter":
			if err := func() error {
				s.TrashedAfter.Reset()
				if err := s.TrashedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedAfter\"")
			}
		case "trashedBefore":
			if err := func() error {
				s.TrashedBefore.Reset()
				if err := s.TrashedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedBefore\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "updatedAfter":
			if err := func() error {
				s.UpdatedAfter.Reset()
				if err := s.UpdatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAfter\"")
			}
		case "updatedBefore":
			if err := func() error {
				s.UpdatedBefore.Reset()
				if err := s.UpdatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBefore\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "withDeleted":
			if err := func() error {
				s.WithDeleted.Reset()
				if err := s.WithDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withDeleted\"")
			}
		case "withExif":
			if err := func() error {
				s.WithExif.Reset()
				if err := s.WithExif.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withExif\"")
			}
		case "withPeople":
			if err := func() error {
				s.WithPeople.Reset()
				if err := s.WithPeople.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withPeople\"")
			}
		case "withStacked":
			if err := func() error {
				s.WithStacked.Reset()
				if err := s.WithStacked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withStacked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetadataSearchDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetadataSearchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetadataSearchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o NilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o NilFloat64) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *NilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o NilInt64) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *NilInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int64
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PersonResponseDto as json.
func (o NilPersonResponseDto) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PersonResponseDto from json.
func (o *NilPersonResponseDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPersonResponseDto to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PersonResponseDto
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilPersonResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilPersonResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserLicense as json.
func (o NilUserLicense) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserLicense from json.
func (o *NilUserLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUserLicense to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserLicense
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUserLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUserLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.ReadAt.Set {
			e.FieldStart("readAt")
			s.ReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("userId")
		json.EncodeUUID(e, s.UserId)
	}
}

var jsonFieldsNameOfNotificationCreateDto = [7]string{
	0: "data",
	1: "description",
	2: "level",
	3: "readAt",
	4: "title",
	5: "type",
	6: "userId",
}

// Decode decodes NotificationCreateDto from json.
func (s *NotificationCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = nil
				var elem NotificationCreateDtoData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "readAt":
			if err := func() error {
				s.ReadAt.Reset()
				if err := s.ReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readAt\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationCreateDto) {
					name = jsonFieldsNameOfNotificationCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationCreateDtoData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationCreateDtoData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNotificationCreateDtoData = [0]string{}

// Decode decodes NotificationCreateDtoData from json.
func (s *NotificationCreateDtoData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationCreateDtoData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NotificationCreateDtoData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationCreateDtoData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationCreateDtoData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationDeleteAllDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationDeleteAllDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNotificationDeleteAllDto = [1]string{
	0: "ids",
}

// Decode decodes NotificationDeleteAllDto from json.
func (s *NotificationDeleteAllDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationDeleteAllDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationDeleteAllDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationDeleteAllDto) {
					name = jsonFieldsNameOfNotificationDeleteAllDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationDeleteAllDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationDeleteAllDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		if s.ReadAt.Set {
			e.FieldStart("readAt")
			s.ReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfNotificationDto = [8]string{
	0: "createdAt",
	1: "data",
	2: "description",
	3: "id",
	4: "level",
	5: "readAt",
	6: "title",
	7: "type",
}

// Decode decodes NotificationDto from json.
func (s *NotificationDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "data":
			if err := func() error {
				s.Data = nil
				var elem NotificationDtoData
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Data = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "readAt":
			if err := func() error {
				s.ReadAt.Reset()
				if err := s.ReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readAt\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationDto) {
					name = jsonFieldsNameOfNotificationDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationDtoData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationDtoData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNotificationDtoData = [0]string{}

// Decode decodes NotificationDtoData from json.
func (s *NotificationDtoData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationDtoData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NotificationDtoData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationDtoData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationDtoData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationLevel as json.
func (s NotificationLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationLevel from json.
func (s *NotificationLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationLevel(v) {
	case NotificationLevelSuccess:
		*s = NotificationLevelSuccess
	case NotificationLevelError:
		*s = NotificationLevelError
	case NotificationLevelWarning:
		*s = NotificationLevelWarning
	case NotificationLevelInfo:
		*s = NotificationLevelInfo
	default:
		*s = NotificationLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationType as json.
func (s NotificationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationType from json.
func (s *NotificationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationType(v) {
	case NotificationTypeJobFailed:
		*s = NotificationTypeJobFailed
	case NotificationTypeBackupFailed:
		*s = NotificationTypeBackupFailed
	case NotificationTypeSystemMessage:
		*s = NotificationTypeSystemMessage
	case NotificationTypeAlbumInvite:
		*s = NotificationTypeAlbumInvite
	case NotificationTypeAlbumUpdate:
		*s = NotificationTypeAlbumUpdate
	case NotificationTypeCustom:
		*s = NotificationTypeCustom
	default:
		*s = NotificationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationUpdateAllDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationUpdateAllDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		if s.ReadAt.Set {
			e.FieldStart("readAt")
			s.ReadAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfNotificationUpdateAllDto = [2]string{
	0: "ids",
	1: "readAt",
}

// Decode decodes NotificationUpdateAllDto from json.
func (s *NotificationUpdateAllDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationUpdateAllDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "readAt":
			if err := func() error {
				s.ReadAt.Reset()
				if err := s.ReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationUpdateAllDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationUpdateAllDto) {
					name = jsonFieldsNameOfNotificationUpdateAllDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationUpdateAllDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationUpdateAllDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.ReadAt.Set {
			e.FieldStart("readAt")
			s.ReadAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfNotificationUpdateDto = [1]string{
	0: "readAt",
}

// Decode decodes NotificationUpdateDto from json.
func (s *NotificationUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readAt":
			if err := func() error {
				s.ReadAt.Reset()
				if err := s.ReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthAuthorizeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthAuthorizeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfOAuthAuthorizeResponseDto = [1]string{
	0: "url",
}

// Decode decodes OAuthAuthorizeResponseDto from json.
func (s *OAuthAuthorizeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthAuthorizeResponseDto) {
					name = jsonFieldsNameOfOAuthAuthorizeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthAuthorizeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthAuthorizeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthCallbackDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthCallbackDto) encodeFields(e *jx.Encoder) {
	{
		if s.CodeVerifier.Set {
			e.FieldStart("codeVerifier")
			s.CodeVerifier.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfOAuthCallbackDto = [3]string{
	0: "codeVerifier",
	1: "state",
	2: "url",
}

// Decode decodes OAuthCallbackDto from json.
func (s *OAuthCallbackDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthCallbackDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "codeVerifier":
			if err := func() error {
				s.CodeVerifier.Reset()
				if err := s.CodeVerifier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"codeVerifier\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthCallbackDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthCallbackDto) {
					name = jsonFieldsNameOfOAuthCallbackDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthCallbackDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthCallbackDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthConfigDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthConfigDto) encodeFields(e *jx.Encoder) {
	{
		if s.CodeChallenge.Set {
			e.FieldStart("codeChallenge")
			s.CodeChallenge.Encode(e)
		}
	}
	{
		e.FieldStart("redirectUri")
		e.Str(s.RedirectUri)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuthConfigDto = [3]string{
	0: "codeChallenge",
	1: "redirectUri",
	2: "state",
}

// Decode decodes OAuthConfigDto from json.
func (s *OAuthConfigDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthConfigDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "codeChallenge":
			if err := func() error {
				s.CodeChallenge.Reset()
				if err := s.CodeChallenge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"codeChallenge\"")
			}
		case "redirectUri":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RedirectUri = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redirectUri\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthConfigDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthConfigDto) {
					name = jsonFieldsNameOfOAuthConfigDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthConfigDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthConfigDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthTokenEndpointAuthMethod as json.
func (s OAuthTokenEndpointAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuthTokenEndpointAuthMethod from json.
func (s *OAuthTokenEndpointAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthTokenEndpointAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuthTokenEndpointAuthMethod(v) {
	case OAuthTokenEndpointAuthMethodClientSecretPost:
		*s = OAuthTokenEndpointAuthMethodClientSecretPost
	case OAuthTokenEndpointAuthMethodClientSecretBasic:
		*s = OAuthTokenEndpointAuthMethodClientSecretBasic
	default:
		*s = OAuthTokenEndpointAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuthTokenEndpointAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthTokenEndpointAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OnThisDayDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OnThisDayDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("year")
		e.Float64(s.Year)
	}
}

var jsonFieldsNameOfOnThisDayDto = [1]string{
	0: "year",
}

// Decode decodes OnThisDayDto from json.
func (s *OnThisDayDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OnThisDayDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "year":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Year = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"year\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OnThisDayDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOnThisDayDto) {
					name = jsonFieldsNameOfOnThisDayDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OnThisDayDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OnThisDayDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OnboardingDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OnboardingDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isOnboarded")
		e.Bool(s.IsOnboarded)
	}
}

var jsonFieldsNameOfOnboardingDto = [1]string{
	0: "isOnboarded",
}

// Decode decodes OnboardingDto from json.
func (s *OnboardingDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OnboardingDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isOnboarded":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboarded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOnboarded\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OnboardingDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOnboardingDto) {
					name = jsonFieldsNameOfOnboardingDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OnboardingDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OnboardingDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OnboardingResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OnboardingResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isOnboarded")
		e.Bool(s.IsOnboarded)
	}
}

var jsonFieldsNameOfOnboardingResponseDto = [1]string{
	0: "isOnboarded",
}

// Decode decodes OnboardingResponseDto from json.
func (s *OnboardingResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OnboardingResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isOnboarded":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboarded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOnboarded\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OnboardingResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOnboardingResponseDto) {
					name = jsonFieldsNameOfOnboardingResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OnboardingResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OnboardingResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlbumResponseDto as json.
func (o OptAlbumResponseDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlbumResponseDto from json.
func (o *OptAlbumResponseDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlbumResponseDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlbumResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlbumResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlbumUserRole as json.
func (o OptAlbumUserRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AlbumUserRole from json.
func (o *OptAlbumUserRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlbumUserRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlbumUserRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlbumUserRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlbumsUpdate as json.
func (o OptAlbumsUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlbumsUpdate from json.
func (o *OptAlbumsUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlbumsUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlbumsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlbumsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetBulkUploadCheckResultReason as json.
func (o OptAssetBulkUploadCheckResultReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssetBulkUploadCheckResultReason from json.
func (o *OptAssetBulkUploadCheckResultReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssetBulkUploadCheckResultReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssetBulkUploadCheckResultReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssetBulkUploadCheckResultReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetIdsResponseDtoError as json.
func (o OptAssetIdsResponseDtoError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssetIdsResponseDtoError from json.
func (o *OptAssetIdsResponseDtoError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssetIdsResponseDtoError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssetIdsResponseDtoError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssetIdsResponseDtoError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetOrder as json.
func (o OptAssetOrder) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssetOrder from json.
func (o *OptAssetOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssetOrder to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssetOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssetOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetTypeEnum as json.
func (o OptAssetTypeEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssetTypeEnum from json.
func (o *OptAssetTypeEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssetTypeEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssetTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssetTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetVisibility as json.
func (o OptAssetVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssetVisibility from json.
func (o *OptAssetVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssetVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssetVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssetVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AvatarUpdate as json.
func (o OptAvatarUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AvatarUpdate from json.
func (o *OptAvatarUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAvatarUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAvatarUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAvatarUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkIdErrorReason as json.
func (o OptBulkIdErrorReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkIdErrorReason from json.
func (o *OptBulkIdErrorReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkIdErrorReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkIdErrorReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkIdErrorReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkIdResponseDtoError as json.
func (o OptBulkIdResponseDtoError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkIdResponseDtoError from json.
func (o *OptBulkIdResponseDtoError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkIdResponseDtoError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkIdResponseDtoError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkIdResponseDtoError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CastUpdate as json.
func (o OptCastUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CastUpdate from json.
func (o *OptCastUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCastUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCastUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCastUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DownloadUpdate as json.
func (o OptDownloadUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DownloadUpdate from json.
func (o *OptDownloadUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDownloadUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDownloadUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDownloadUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EmailNotificationsUpdate as json.
func (o OptEmailNotificationsUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EmailNotificationsUpdate from json.
func (o *OptEmailNotificationsUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEmailNotificationsUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEmailNotificationsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEmailNotificationsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExifResponseDto as json.
func (o OptExifResponseDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExifResponseDto from json.
func (o *OptExifResponseDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExifResponseDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExifResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExifResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FoldersUpdate as json.
func (o OptFoldersUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FoldersUpdate from json.
func (o *OptFoldersUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFoldersUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFoldersUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFoldersUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MemoriesUpdate as json.
func (o OptMemoriesUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MemoriesUpdate from json.
func (o *OptMemoriesUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMemoriesUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMemoriesUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMemoriesUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MemoryType as json.
func (o OptMemoryType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MemoryType from json.
func (o *OptMemoryType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMemoryType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMemoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMemoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssetStackResponseDto as json.
func (o OptNilAssetStackResponseDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AssetStackResponseDto from json.
func (o *OptNilAssetStackResponseDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAssetStackResponseDto to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AssetStackResponseDto
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAssetStackResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAssetStackResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptNilInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptNilInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []uuid.UUID as json.
func (o OptNilUUIDArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		json.EncodeUUID(e, elem)
	}
	e.ArrEnd()
}

// Decode decodes []uuid.UUID from json.
func (o *OptNilUUIDArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUIDArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]uuid.UUID, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem uuid.UUID
		v, err := json.DecodeUUID(d)
		elem = v
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUIDArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUIDArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAvatarColor as json.
func (o OptNilUserAvatarColor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserAvatarColor from json.
func (o *OptNilUserAvatarColor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUserAvatarColor to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserAvatarColor
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUserAvatarColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUserAvatarColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationLevel as json.
func (o OptNotificationLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationLevel from json.
func (o *OptNotificationLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationType as json.
func (o OptNotificationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationType from json.
func (o *OptNotificationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PeopleUpdate as json.
func (o OptPeopleUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PeopleUpdate from json.
func (o *OptPeopleUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPeopleUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPeopleUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPeopleUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PurchaseUpdate as json.
func (o OptPurchaseUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PurchaseUpdate from json.
func (o *OptPurchaseUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPurchaseUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPurchaseUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPurchaseUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RatingsUpdate as json.
func (o OptRatingsUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RatingsUpdate from json.
func (o *OptRatingsUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRatingsUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRatingsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRatingsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SharedLinksUpdate as json.
func (o OptSharedLinksUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SharedLinksUpdate from json.
func (o *OptSharedLinksUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSharedLinksUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSharedLinksUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSharedLinksUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SourceType as json.
func (o OptSourceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SourceType from json.
func (o *OptSourceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSourceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagsUpdate as json.
func (o OptTagsUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TagsUpdate from json.
func (o *OptTagsUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTagsUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTagsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTagsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAvatarColor as json.
func (o OptUserAvatarColor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserAvatarColor from json.
func (o *OptUserAvatarColor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAvatarColor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAvatarColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAvatarColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserResponseDto as json.
func (o OptUserResponseDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserResponseDto from json.
func (o *OptUserResponseDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserResponseDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartnerCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartnerCreateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sharedWithId")
		json.EncodeUUID(e, s.SharedWithId)
	}
}

var jsonFieldsNameOfPartnerCreateDto = [1]string{
	0: "sharedWithId",
}

// Decode decodes PartnerCreateDto from json.
func (s *PartnerCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartnerCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sharedWithId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SharedWithId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharedWithId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartnerCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartnerCreateDto) {
					name = jsonFieldsNameOfPartnerCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartnerCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartnerCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartnerResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartnerResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatarColor")
		s.AvatarColor.Encode(e)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.InTimeline.Set {
			e.FieldStart("inTimeline")
			s.InTimeline.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("profileChangedAt")
		json.EncodeDateTime(e, s.ProfileChangedAt)
	}
	{
		e.FieldStart("profileImagePath")
		e.Str(s.ProfileImagePath)
	}
}

var jsonFieldsNameOfPartnerResponseDto = [7]string{
	0: "avatarColor",
	1: "email",
	2: "id",
	3: "inTimeline",
	4: "name",
	5: "profileChangedAt",
	6: "profileImagePath",
}

// Decode decodes PartnerResponseDto from json.
func (s *PartnerResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartnerResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatarColor":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AvatarColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatarColor\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "inTimeline":
			if err := func() error {
				s.InTimeline.Reset()
				if err := s.InTimeline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inTimeline\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "profileChangedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ProfileChangedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileChangedAt\"")
			}
		case "profileImagePath":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ProfileImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileImagePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartnerResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartnerResponseDto) {
					name = jsonFieldsNameOfPartnerResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartnerResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartnerResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartnerUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartnerUpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inTimeline")
		e.Bool(s.InTimeline)
	}
}

var jsonFieldsNameOfPartnerUpdateDto = [1]string{
	0: "inTimeline",
}

// Decode decodes PartnerUpdateDto from json.
func (s *PartnerUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartnerUpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inTimeline":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.InTimeline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inTimeline\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartnerUpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartnerUpdateDto) {
					name = jsonFieldsNameOfPartnerUpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartnerUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartnerUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PeopleResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PeopleResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("sidebarWeb")
		e.Bool(s.SidebarWeb)
	}
}

var jsonFieldsNameOfPeopleResponse = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes PeopleResponse from json.
func (s *PeopleResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeopleResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SidebarWeb = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PeopleResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPeopleResponse) {
					name = jsonFieldsNameOfPeopleResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PeopleResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeopleResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PeopleResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PeopleResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.HasNextPage.Set {
			e.FieldStart("hasNextPage")
			s.HasNextPage.Encode(e)
		}
	}
	{
		e.FieldStart("hidden")
		e.Int(s.Hidden)
	}
	{
		e.FieldStart("people")
		e.ArrStart()
		for _, elem := range s.People {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfPeopleResponseDto = [4]string{
	0: "hasNextPage",
	1: "hidden",
	2: "people",
	3: "total",
}

// Decode decodes PeopleResponseDto from json.
func (s *PeopleResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeopleResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hasNextPage":
			if err := func() error {
				s.HasNextPage.Reset()
				if err := s.HasNextPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasNextPage\"")
			}
		case "hidden":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Hidden = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "people":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.People = make([]PersonResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.People = append(s.People, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"people\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PeopleResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPeopleResponseDto) {
					name = jsonFieldsNameOfPeopleResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PeopleResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeopleResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PeopleUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PeopleUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.SidebarWeb.Set {
			e.FieldStart("sidebarWeb")
			s.SidebarWeb.Encode(e)
		}
	}
}

var jsonFieldsNameOfPeopleUpdate = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes PeopleUpdate from json.
func (s *PeopleUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeopleUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			if err := func() error {
				s.SidebarWeb.Reset()
				if err := s.SidebarWeb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PeopleUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PeopleUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeopleUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PeopleUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PeopleUpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("people")
		e.ArrStart()
		for _, elem := range s.People {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPeopleUpdateDto = [1]string{
	0: "people",
}

// Decode decodes PeopleUpdateDto from json.
func (s *PeopleUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeopleUpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "people":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.People = make([]PeopleUpdateItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PeopleUpdateItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.People = append(s.People, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"people\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PeopleUpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPeopleUpdateDto) {
					name = jsonFieldsNameOfPeopleUpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PeopleUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeopleUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PeopleUpdateItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PeopleUpdateItem) encodeFields(e *jx.Encoder) {
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.FeatureFaceAssetId.Set {
			e.FieldStart("featureFaceAssetId")
			s.FeatureFaceAssetId.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfPeopleUpdateItem = [7]string{
	0: "birthDate",
	1: "color",
	2: "featureFaceAssetId",
	3: "id",
	4: "isFavorite",
	5: "isHidden",
	6: "name",
}

// Decode decodes PeopleUpdateItem from json.
func (s *PeopleUpdateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PeopleUpdateItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "featureFaceAssetId":
			if err := func() error {
				s.FeatureFaceAssetId.Reset()
				if err := s.FeatureFaceAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureFaceAssetId\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PeopleUpdateItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPeopleUpdateItem) {
					name = jsonFieldsNameOfPeopleUpdateItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PeopleUpdateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PeopleUpdateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Permission as json.
func (s Permission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Permission from json.
func (s *Permission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Permission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Permission(v) {
	case PermissionAll:
		*s = PermissionAll
	case PermissionActivityCreate:
		*s = PermissionActivityCreate
	case PermissionActivityRead:
		*s = PermissionActivityRead
	case PermissionActivityUpdate:
		*s = PermissionActivityUpdate
	case PermissionActivityDelete:
		*s = PermissionActivityDelete
	case PermissionActivityStatistics:
		*s = PermissionActivityStatistics
	case PermissionApiKeyCreate:
		*s = PermissionApiKeyCreate
	case PermissionApiKeyRead:
		*s = PermissionApiKeyRead
	case PermissionApiKeyUpdate:
		*s = PermissionApiKeyUpdate
	case PermissionApiKeyDelete:
		*s = PermissionApiKeyDelete
	case PermissionAssetRead:
		*s = PermissionAssetRead
	case PermissionAssetUpdate:
		*s = PermissionAssetUpdate
	case PermissionAssetDelete:
		*s = PermissionAssetDelete
	case PermissionAssetStatistics:
		*s = PermissionAssetStatistics
	case PermissionAssetShare:
		*s = PermissionAssetShare
	case PermissionAssetView:
		*s = PermissionAssetView
	case PermissionAssetDownload:
		*s = PermissionAssetDownload
	case PermissionAssetUpload:
		*s = PermissionAssetUpload
	case PermissionAssetReplace:
		*s = PermissionAssetReplace
	case PermissionAlbumCreate:
		*s = PermissionAlbumCreate
	case PermissionAlbumRead:
		*s = PermissionAlbumRead
	case PermissionAlbumUpdate:
		*s = PermissionAlbumUpdate
	case PermissionAlbumDelete:
		*s = PermissionAlbumDelete
	case PermissionAlbumStatistics:
		*s = PermissionAlbumStatistics
	case PermissionAlbumShare:
		*s = PermissionAlbumShare
	case PermissionAlbumDownload:
		*s = PermissionAlbumDownload
	case PermissionAlbumAssetCreate:
		*s = PermissionAlbumAssetCreate
	case PermissionAlbumAssetDelete:
		*s = PermissionAlbumAssetDelete
	case PermissionAlbumUserCreate:
		*s = PermissionAlbumUserCreate
	case PermissionAlbumUserUpdate:
		*s = PermissionAlbumUserUpdate
	case PermissionAlbumUserDelete:
		*s = PermissionAlbumUserDelete
	case PermissionAuthChangePassword:
		*s = PermissionAuthChangePassword
	case PermissionAuthDeviceDelete:
		*s = PermissionAuthDeviceDelete
	case PermissionArchiveRead:
		*s = PermissionArchiveRead
	case PermissionDuplicateRead:
		*s = PermissionDuplicateRead
	case PermissionDuplicateDelete:
		*s = PermissionDuplicateDelete
	case PermissionFaceCreate:
		*s = PermissionFaceCreate
	case PermissionFaceRead:
		*s = PermissionFaceRead
	case PermissionFaceUpdate:
		*s = PermissionFaceUpdate
	case PermissionFaceDelete:
		*s = PermissionFaceDelete
	case PermissionJobCreate:
		*s = PermissionJobCreate
	case PermissionJobRead:
		*s = PermissionJobRead
	case PermissionLibraryCreate:
		*s = PermissionLibraryCreate
	case PermissionLibraryRead:
		*s = PermissionLibraryRead
	case PermissionLibraryUpdate:
		*s = PermissionLibraryUpdate
	case PermissionLibraryDelete:
		*s = PermissionLibraryDelete
	case PermissionLibraryStatistics:
		*s = PermissionLibraryStatistics
	case PermissionTimelineRead:
		*s = PermissionTimelineRead
	case PermissionTimelineDownload:
		*s = PermissionTimelineDownload
	case PermissionMemoryCreate:
		*s = PermissionMemoryCreate
	case PermissionMemoryRead:
		*s = PermissionMemoryRead
	case PermissionMemoryUpdate:
		*s = PermissionMemoryUpdate
	case PermissionMemoryDelete:
		*s = PermissionMemoryDelete
	case PermissionMemoryStatistics:
		*s = PermissionMemoryStatistics
	case PermissionMemoryAssetCreate:
		*s = PermissionMemoryAssetCreate
	case PermissionMemoryAssetDelete:
		*s = PermissionMemoryAssetDelete
	case PermissionNotificationCreate:
		*s = PermissionNotificationCreate
	case PermissionNotificationRead:
		*s = PermissionNotificationRead
	case PermissionNotificationUpdate:
		*s = PermissionNotificationUpdate
	case PermissionNotificationDelete:
		*s = PermissionNotificationDelete
	case PermissionPartnerCreate:
		*s = PermissionPartnerCreate
	case PermissionPartnerRead:
		*s = PermissionPartnerRead
	case PermissionPartnerUpdate:
		*s = PermissionPartnerUpdate
	case PermissionPartnerDelete:
		*s = PermissionPartnerDelete
	case PermissionPersonCreate:
		*s = PermissionPersonCreate
	case PermissionPersonRead:
		*s = PermissionPersonRead
	case PermissionPersonUpdate:
		*s = PermissionPersonUpdate
	case PermissionPersonDelete:
		*s = PermissionPersonDelete
	case PermissionPersonStatistics:
		*s = PermissionPersonStatistics
	case PermissionPersonMerge:
		*s = PermissionPersonMerge
	case PermissionPersonReassign:
		*s = PermissionPersonReassign
	case PermissionPinCodeCreate:
		*s = PermissionPinCodeCreate
	case PermissionPinCodeUpdate:
		*s = PermissionPinCodeUpdate
	case PermissionPinCodeDelete:
		*s = PermissionPinCodeDelete
	case PermissionServerAbout:
		*s = PermissionServerAbout
	case PermissionServerApkLinks:
		*s = PermissionServerApkLinks
	case PermissionServerStorage:
		*s = PermissionServerStorage
	case PermissionServerStatistics:
		*s = PermissionServerStatistics
	case PermissionServerVersionCheck:
		*s = PermissionServerVersionCheck
	case PermissionServerLicenseRead:
		*s = PermissionServerLicenseRead
	case PermissionServerLicenseUpdate:
		*s = PermissionServerLicenseUpdate
	case PermissionServerLicenseDelete:
		*s = PermissionServerLicenseDelete
	case PermissionSessionCreate:
		*s = PermissionSessionCreate
	case PermissionSessionRead:
		*s = PermissionSessionRead
	case PermissionSessionUpdate:
		*s = PermissionSessionUpdate
	case PermissionSessionDelete:
		*s = PermissionSessionDelete
	case PermissionSessionLock:
		*s = PermissionSessionLock
	case PermissionSharedLinkCreate:
		*s = PermissionSharedLinkCreate
	case PermissionSharedLinkRead:
		*s = PermissionSharedLinkRead
	case PermissionSharedLinkUpdate:
		*s = PermissionSharedLinkUpdate
	case PermissionSharedLinkDelete:
		*s = PermissionSharedLinkDelete
	case PermissionStackCreate:
		*s = PermissionStackCreate
	case PermissionStackRead:
		*s = PermissionStackRead
	case PermissionStackUpdate:
		*s = PermissionStackUpdate
	case PermissionStackDelete:
		*s = PermissionStackDelete
	case PermissionSyncStream:
		*s = PermissionSyncStream
	case PermissionSyncCheckpointRead:
		*s = PermissionSyncCheckpointRead
	case PermissionSyncCheckpointUpdate:
		*s = PermissionSyncCheckpointUpdate
	case PermissionSyncCheckpointDelete:
		*s = PermissionSyncCheckpointDelete
	case PermissionSystemConfigRead:
		*s = PermissionSystemConfigRead
	case PermissionSystemConfigUpdate:
		*s = PermissionSystemConfigUpdate
	case PermissionSystemMetadataRead:
		*s = PermissionSystemMetadataRead
	case PermissionSystemMetadataUpdate:
		*s = PermissionSystemMetadataUpdate
	case PermissionTagCreate:
		*s = PermissionTagCreate
	case PermissionTagRead:
		*s = PermissionTagRead
	case PermissionTagUpdate:
		*s = PermissionTagUpdate
	case PermissionTagDelete:
		*s = PermissionTagDelete
	case PermissionTagAsset:
		*s = PermissionTagAsset
	case PermissionUserRead:
		*s = PermissionUserRead
	case PermissionUserUpdate:
		*s = PermissionUserUpdate
	case PermissionUserLicenseCreate:
		*s = PermissionUserLicenseCreate
	case PermissionUserLicenseRead:
		*s = PermissionUserLicenseRead
	case PermissionUserLicenseUpdate:
		*s = PermissionUserLicenseUpdate
	case PermissionUserLicenseDelete:
		*s = PermissionUserLicenseDelete
	case PermissionUserOnboardingRead:
		*s = PermissionUserOnboardingRead
	case PermissionUserOnboardingUpdate:
		*s = PermissionUserOnboardingUpdate
	case PermissionUserOnboardingDelete:
		*s = PermissionUserOnboardingDelete
	case PermissionUserPreferenceRead:
		*s = PermissionUserPreferenceRead
	case PermissionUserPreferenceUpdate:
		*s = PermissionUserPreferenceUpdate
	case PermissionUserProfileImageCreate:
		*s = PermissionUserProfileImageCreate
	case PermissionUserProfileImageRead:
		*s = PermissionUserProfileImageRead
	case PermissionUserProfileImageUpdate:
		*s = PermissionUserProfileImageUpdate
	case PermissionUserProfileImageDelete:
		*s = PermissionUserProfileImageDelete
	case PermissionAdminUserCreate:
		*s = PermissionAdminUserCreate
	case PermissionAdminUserRead:
		*s = PermissionAdminUserRead
	case PermissionAdminUserUpdate:
		*s = PermissionAdminUserUpdate
	case PermissionAdminUserDelete:
		*s = PermissionAdminUserDelete
	case PermissionAdminAuthUnlinkAll:
		*s = PermissionAdminAuthUnlinkAll
	default:
		*s = Permission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Permission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Permission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonCreateDto = [5]string{
	0: "birthDate",
	1: "color",
	2: "isFavorite",
	3: "isHidden",
	4: "name",
}

// Decode decodes PersonCreateDto from json.
func (s *PersonCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonCreateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonCreateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("birthDate")
		s.BirthDate.Encode(e, json.EncodeDate)
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		e.FieldStart("isHidden")
		e.Bool(s.IsHidden)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("thumbnailPath")
		e.Str(s.ThumbnailPath)
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPersonResponseDto = [8]string{
	0: "birthDate",
	1: "color",
	2: "id",
	3: "isFavorite",
	4: "isHidden",
	5: "name",
	6: "thumbnailPath",
	7: "updatedAt",
}

// Decode decodes PersonResponseDto from json.
func (s *PersonResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "birthDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isHidden":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsHidden = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "thumbnailPath":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ThumbnailPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnailPath\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonResponseDto) {
					name = jsonFieldsNameOfPersonResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assets")
		e.Int(s.Assets)
	}
}

var jsonFieldsNameOfPersonStatisticsResponseDto = [1]string{
	0: "assets",
}

// Decode decodes PersonStatisticsResponseDto from json.
func (s *PersonStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Assets = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonStatisticsResponseDto) {
					name = jsonFieldsNameOfPersonStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.FeatureFaceAssetId.Set {
			e.FieldStart("featureFaceAssetId")
			s.FeatureFaceAssetId.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonUpdateDto = [6]string{
	0: "birthDate",
	1: "color",
	2: "featureFaceAssetId",
	3: "isFavorite",
	4: "isHidden",
	5: "name",
}

// Decode decodes PersonUpdateDto from json.
func (s *PersonUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "featureFaceAssetId":
			if err := func() error {
				s.FeatureFaceAssetId.Reset()
				if err := s.FeatureFaceAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureFaceAssetId\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonWithFacesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonWithFacesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("birthDate")
		s.BirthDate.Encode(e, json.EncodeDate)
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		e.FieldStart("faces")
		e.ArrStart()
		for _, elem := range s.Faces {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		e.FieldStart("isHidden")
		e.Bool(s.IsHidden)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("thumbnailPath")
		e.Str(s.ThumbnailPath)
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPersonWithFacesResponseDto = [9]string{
	0: "birthDate",
	1: "color",
	2: "faces",
	3: "id",
	4: "isFavorite",
	5: "isHidden",
	6: "name",
	7: "thumbnailPath",
	8: "updatedAt",
}

// Decode decodes PersonWithFacesResponseDto from json.
func (s *PersonWithFacesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonWithFacesResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "birthDate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "faces":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Faces = make([]AssetFaceWithoutPersonResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetFaceWithoutPersonResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Faces = append(s.Faces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faces\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isHidden":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsHidden = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "thumbnailPath":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ThumbnailPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnailPath\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonWithFacesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonWithFacesResponseDto) {
					name = jsonFieldsNameOfPersonWithFacesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonWithFacesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonWithFacesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PinCodeChangeDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PinCodeChangeDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("newPinCode")
		e.Str(s.NewPinCode)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PinCode.Set {
			e.FieldStart("pinCode")
			s.PinCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPinCodeChangeDto = [3]string{
	0: "newPinCode",
	1: "password",
	2: "pinCode",
}

// Decode decodes PinCodeChangeDto from json.
func (s *PinCodeChangeDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PinCodeChangeDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "newPinCode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewPinCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newPinCode\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "pinCode":
			if err := func() error {
				s.PinCode.Reset()
				if err := s.PinCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PinCodeChangeDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPinCodeChangeDto) {
					name = jsonFieldsNameOfPinCodeChangeDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PinCodeChangeDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PinCodeChangeDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PinCodeResetDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PinCodeResetDto) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PinCode.Set {
			e.FieldStart("pinCode")
			s.PinCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPinCodeResetDto = [2]string{
	0: "password",
	1: "pinCode",
}

// Decode decodes PinCodeResetDto from json.
func (s *PinCodeResetDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PinCodeResetDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "pinCode":
			if err := func() error {
				s.PinCode.Reset()
				if err := s.PinCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PinCodeResetDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PinCodeResetDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PinCodeResetDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PinCodeSetupDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PinCodeSetupDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pinCode")
		e.Str(s.PinCode)
	}
}

var jsonFieldsNameOfPinCodeSetupDto = [1]string{
	0: "pinCode",
}

// Decode decodes PinCodeSetupDto from json.
func (s *PinCodeSetupDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PinCodeSetupDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pinCode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PinCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PinCodeSetupDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPinCodeSetupDto) {
					name = jsonFieldsNameOfPinCodeSetupDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PinCodeSetupDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PinCodeSetupDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlacesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlacesResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.Admin1name.Set {
			e.FieldStart("admin1name")
			s.Admin1name.Encode(e)
		}
	}
	{
		if s.Admin2name.Set {
			e.FieldStart("admin2name")
			s.Admin2name.Encode(e)
		}
	}
	{
		e.FieldStart("latitude")
		e.Float64(s.Latitude)
	}
	{
		e.FieldStart("longitude")
		e.Float64(s.Longitude)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfPlacesResponseDto = [5]string{
	0: "admin1name",
	1: "admin2name",
	2: "latitude",
	3: "longitude",
	4: "name",
}

// Decode decodes PlacesResponseDto from json.
func (s *PlacesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlacesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin1name":
			if err := func() error {
				s.Admin1name.Reset()
				if err := s.Admin1name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin1name\"")
			}
		case "admin2name":
			if err := func() error {
				s.Admin2name.Reset()
				if err := s.Admin2name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin2name\"")
			}
		case "latitude":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Latitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Longitude = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlacesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlacesResponseDto) {
					name = jsonFieldsNameOfPlacesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlacesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlacesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PurchaseResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PurchaseResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hideBuyButtonUntil")
		e.Str(s.HideBuyButtonUntil)
	}
	{
		e.FieldStart("showSupportBadge")
		e.Bool(s.ShowSupportBadge)
	}
}

var jsonFieldsNameOfPurchaseResponse = [2]string{
	0: "hideBuyButtonUntil",
	1: "showSupportBadge",
}

// Decode decodes PurchaseResponse from json.
func (s *PurchaseResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PurchaseResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hideBuyButtonUntil":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HideBuyButtonUntil = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hideBuyButtonUntil\"")
			}
		case "showSupportBadge":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ShowSupportBadge = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"showSupportBadge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PurchaseResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPurchaseResponse) {
					name = jsonFieldsNameOfPurchaseResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PurchaseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PurchaseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PurchaseUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PurchaseUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.HideBuyButtonUntil.Set {
			e.FieldStart("hideBuyButtonUntil")
			s.HideBuyButtonUntil.Encode(e)
		}
	}
	{
		if s.ShowSupportBadge.Set {
			e.FieldStart("showSupportBadge")
			s.ShowSupportBadge.Encode(e)
		}
	}
}

var jsonFieldsNameOfPurchaseUpdate = [2]string{
	0: "hideBuyButtonUntil",
	1: "showSupportBadge",
}

// Decode decodes PurchaseUpdate from json.
func (s *PurchaseUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PurchaseUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hideBuyButtonUntil":
			if err := func() error {
				s.HideBuyButtonUntil.Reset()
				if err := s.HideBuyButtonUntil.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hideBuyButtonUntil\"")
			}
		case "showSupportBadge":
			if err := func() error {
				s.ShowSupportBadge.Reset()
				if err := s.ShowSupportBadge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"showSupportBadge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PurchaseUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PurchaseUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PurchaseUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueueStatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueueStatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("isPaused")
		e.Bool(s.IsPaused)
	}
}

var jsonFieldsNameOfQueueStatusDto = [2]string{
	0: "isActive",
	1: "isPaused",
}

// Decode decodes QueueStatusDto from json.
func (s *QueueStatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueStatusDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isActive":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "isPaused":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsPaused = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPaused\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueueStatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueueStatusDto) {
					name = jsonFieldsNameOfQueueStatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueueStatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueStatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RandomSearchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RandomSearchDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumIds != nil {
			e.FieldStart("albumIds")
			e.ArrStart()
			for _, elem := range s.AlbumIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.City.Set {
			e.FieldStart("city")
			s.City.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.CreatedAfter.Set {
			e.FieldStart("createdAfter")
			s.CreatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBefore.Set {
			e.FieldStart("createdBefore")
			s.CreatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DeviceId.Set {
			e.FieldStart("deviceId")
			s.DeviceId.Encode(e)
		}
	}
	{
		if s.IsEncoded.Set {
			e.FieldStart("isEncoded")
			s.IsEncoded.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsMotion.Set {
			e.FieldStart("isMotion")
			s.IsMotion.Encode(e)
		}
	}
	{
		if s.IsNotInAlbum.Set {
			e.FieldStart("isNotInAlbum")
			s.IsNotInAlbum.Encode(e)
		}
	}
	{
		if s.IsOffline.Set {
			e.FieldStart("isOffline")
			s.IsOffline.Encode(e)
		}
	}
	{
		if s.LensModel.Set {
			e.FieldStart("lensModel")
			s.LensModel.Encode(e)
		}
	}
	{
		if s.LibraryId.Set {
			e.FieldStart("libraryId")
			s.LibraryId.Encode(e)
		}
	}
	{
		if s.Make.Set {
			e.FieldStart("make")
			s.Make.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.PersonIds != nil {
			e.FieldStart("personIds")
			e.ArrStart()
			for _, elem := range s.PersonIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TagIds.Set {
			e.FieldStart("tagIds")
			s.TagIds.Encode(e)
		}
	}
	{
		if s.TakenAfter.Set {
			e.FieldStart("takenAfter")
			s.TakenAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TakenBefore.Set {
			e.FieldStart("takenBefore")
			s.TakenBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedAfter.Set {
			e.FieldStart("trashedAfter")
			s.TrashedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedBefore.Set {
			e.FieldStart("trashedBefore")
			s.TrashedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.UpdatedAfter.Set {
			e.FieldStart("updatedAfter")
			s.UpdatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBefore.Set {
			e.FieldStart("updatedBefore")
			s.UpdatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.WithDeleted.Set {
			e.FieldStart("withDeleted")
			s.WithDeleted.Encode(e)
		}
	}
	{
		if s.WithExif.Set {
			e.FieldStart("withExif")
			s.WithExif.Encode(e)
		}
	}
	{
		if s.WithPeople.Set {
			e.FieldStart("withPeople")
			s.WithPeople.Encode(e)
		}
	}
	{
		if s.WithStacked.Set {
			e.FieldStart("withStacked")
			s.WithStacked.Encode(e)
		}
	}
}

var jsonFieldsNameOfRandomSearchDto = [32]string{
	0:  "albumIds",
	1:  "city",
	2:  "country",
	3:  "createdAfter",
	4:  "createdBefore",
	5:  "deviceId",
	6:  "isEncoded",
	7:  "isFavorite",
	8:  "isMotion",
	9:  "isNotInAlbum",
	10: "isOffline",
	11: "lensModel",
	12: "libraryId",
	13: "make",
	14: "model",
	15: "personIds",
	16: "rating",
	17: "size",
	18: "state",
	19: "tagIds",
	20: "takenAfter",
	21: "takenBefore",
	22: "trashedAfter",
	23: "trashedBefore",
	24: "type",
	25: "updatedAfter",
	26: "updatedBefore",
	27: "visibility",
	28: "withDeleted",
	29: "withExif",
	30: "withPeople",
	31: "withStacked",
}

// Decode decodes RandomSearchDto from json.
func (s *RandomSearchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RandomSearchDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumIds":
			if err := func() error {
				s.AlbumIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AlbumIds = append(s.AlbumIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumIds\"")
			}
		case "city":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "createdAfter":
			if err := func() error {
				s.CreatedAfter.Reset()
				if err := s.CreatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAfter\"")
			}
		case "createdBefore":
			if err := func() error {
				s.CreatedBefore.Reset()
				if err := s.CreatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBefore\"")
			}
		case "deviceId":
			if err := func() error {
				s.DeviceId.Reset()
				if err := s.DeviceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceId\"")
			}
		case "isEncoded":
			if err := func() error {
				s.IsEncoded.Reset()
				if err := s.IsEncoded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEncoded\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isMotion":
			if err := func() error {
				s.IsMotion.Reset()
				if err := s.IsMotion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMotion\"")
			}
		case "isNotInAlbum":
			if err := func() error {
				s.IsNotInAlbum.Reset()
				if err := s.IsNotInAlbum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNotInAlbum\"")
			}
		case "isOffline":
			if err := func() error {
				s.IsOffline.Reset()
				if err := s.IsOffline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOffline\"")
			}
		case "lensModel":
			if err := func() error {
				s.LensModel.Reset()
				if err := s.LensModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lensModel\"")
			}
		case "libraryId":
			if err := func() error {
				s.LibraryId.Reset()
				if err := s.LibraryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"libraryId\"")
			}
		case "make":
			if err := func() error {
				s.Make.Reset()
				if err := s.Make.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"make\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "personIds":
			if err := func() error {
				s.PersonIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PersonIds = append(s.PersonIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personIds\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "tagIds":
			if err := func() error {
				s.TagIds.Reset()
				if err := s.TagIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagIds\"")
			}
		case "takenAfter":
			if err := func() error {
				s.TakenAfter.Reset()
				if err := s.TakenAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenAfter\"")
			}
		case "takenBefore":
			if err := func() error {
				s.TakenBefore.Reset()
				if err := s.TakenBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenBefore\"")
			}
		case "trashedAfter":
			if err := func() error {
				s.TrashedAfter.Reset()
				if err := s.TrashedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedAfter\"")
			}
		case "trashedBefore":
			if err := func() error {
				s.TrashedBefore.Reset()
				if err := s.TrashedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedBefore\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "updatedAfter":
			if err := func() error {
				s.UpdatedAfter.Reset()
				if err := s.UpdatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAfter\"")
			}
		case "updatedBefore":
			if err := func() error {
				s.UpdatedBefore.Reset()
				if err := s.UpdatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBefore\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "withDeleted":
			if err := func() error {
				s.WithDeleted.Reset()
				if err := s.WithDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withDeleted\"")
			}
		case "withExif":
			if err := func() error {
				s.WithExif.Reset()
				if err := s.WithExif.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withExif\"")
			}
		case "withPeople":
			if err := func() error {
				s.WithPeople.Reset()
				if err := s.WithPeople.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withPeople\"")
			}
		case "withStacked":
			if err := func() error {
				s.WithStacked.Reset()
				if err := s.WithStacked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withStacked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RandomSearchDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RandomSearchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RandomSearchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RatingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RatingsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfRatingsResponse = [1]string{
	0: "enabled",
}

// Decode decodes RatingsResponse from json.
func (s *RatingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RatingsResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RatingsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRatingsResponse) {
					name = jsonFieldsNameOfRatingsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RatingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RatingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RatingsUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RatingsUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfRatingsUpdate = [1]string{
	0: "enabled",
}

// Decode decodes RatingsUpdate from json.
func (s *RatingsUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RatingsUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RatingsUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RatingsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RatingsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReactionType as json.
func (s ReactionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionType from json.
func (s *ReactionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionType(v) {
	case ReactionTypeComment:
		*s = ReactionTypeComment
	case ReactionTypeLike:
		*s = ReactionTypeLike
	default:
		*s = ReactionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReactionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReactionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReverseGeocodingStateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReverseGeocodingStateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastImportFileName")
		s.LastImportFileName.Encode(e)
	}
	{
		e.FieldStart("lastUpdate")
		s.LastUpdate.Encode(e)
	}
}

var jsonFieldsNameOfReverseGeocodingStateResponseDto = [2]string{
	0: "lastImportFileName",
	1: "lastUpdate",
}

// Decode decodes ReverseGeocodingStateResponseDto from json.
func (s *ReverseGeocodingStateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReverseGeocodingStateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastImportFileName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.LastImportFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastImportFileName\"")
			}
		case "lastUpdate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LastUpdate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReverseGeocodingStateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReverseGeocodingStateResponseDto) {
					name = jsonFieldsNameOfReverseGeocodingStateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReverseGeocodingStateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReverseGeocodingStateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchAlbumResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchAlbumResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("facets")
		e.ArrStart()
		for _, elem := range s.Facets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfSearchAlbumResponseDto = [4]string{
	0: "count",
	1: "facets",
	2: "items",
	3: "total",
}

// Decode decodes SearchAlbumResponseDto from json.
func (s *SearchAlbumResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchAlbumResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "facets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Facets = make([]SearchFacetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchFacetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Facets = append(s.Facets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facets\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]AlbumResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlbumResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchAlbumResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchAlbumResponseDto) {
					name = jsonFieldsNameOfSearchAlbumResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchAlbumResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchAlbumResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchAssetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchAssetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("facets")
		e.ArrStart()
		for _, elem := range s.Facets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nextPage")
		s.NextPage.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfSearchAssetResponseDto = [5]string{
	0: "count",
	1: "facets",
	2: "items",
	3: "nextPage",
	4: "total",
}

// Decode decodes SearchAssetResponseDto from json.
func (s *SearchAssetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchAssetResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "facets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Facets = make([]SearchFacetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchFacetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Facets = append(s.Facets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facets\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "nextPage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.NextPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPage\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchAssetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchAssetResponseDto) {
					name = jsonFieldsNameOfSearchAssetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchAssetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchAssetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchExploreItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchExploreItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSearchExploreItem = [2]string{
	0: "data",
	1: "value",
}

// Decode decodes SearchExploreItem from json.
func (s *SearchExploreItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchExploreItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchExploreItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchExploreItem) {
					name = jsonFieldsNameOfSearchExploreItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchExploreItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchExploreItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchExploreResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchExploreResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldName")
		e.Str(s.FieldName)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSearchExploreResponseDto = [2]string{
	0: "fieldName",
	1: "items",
}

// Decode decodes SearchExploreResponseDto from json.
func (s *SearchExploreResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchExploreResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldName\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]SearchExploreItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchExploreItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchExploreResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchExploreResponseDto) {
					name = jsonFieldsNameOfSearchExploreResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchExploreResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchExploreResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchFacetCountResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchFacetCountResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSearchFacetCountResponseDto = [2]string{
	0: "count",
	1: "value",
}

// Decode decodes SearchFacetCountResponseDto from json.
func (s *SearchFacetCountResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchFacetCountResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchFacetCountResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchFacetCountResponseDto) {
					name = jsonFieldsNameOfSearchFacetCountResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchFacetCountResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchFacetCountResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchFacetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchFacetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("counts")
		e.ArrStart()
		for _, elem := range s.Counts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("fieldName")
		e.Str(s.FieldName)
	}
}

var jsonFieldsNameOfSearchFacetResponseDto = [2]string{
	0: "counts",
	1: "fieldName",
}

// Decode decodes SearchFacetResponseDto from json.
func (s *SearchFacetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchFacetResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "counts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Counts = make([]SearchFacetCountResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchFacetCountResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Counts = append(s.Counts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"counts\"")
			}
		case "fieldName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FieldName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchFacetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchFacetResponseDto) {
					name = jsonFieldsNameOfSearchFacetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchFacetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchFacetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albums")
		s.Albums.Encode(e)
	}
	{
		e.FieldStart("assets")
		s.Assets.Encode(e)
	}
}

var jsonFieldsNameOfSearchResponseDto = [2]string{
	0: "albums",
	1: "assets",
}

// Decode decodes SearchResponseDto from json.
func (s *SearchResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albums":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Albums.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albums\"")
			}
		case "assets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Assets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchResponseDto) {
					name = jsonFieldsNameOfSearchResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfSearchStatisticsResponseDto = [1]string{
	0: "total",
}

// Decode decodes SearchStatisticsResponseDto from json.
func (s *SearchStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchStatisticsResponseDto) {
					name = jsonFieldsNameOfSearchStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerAboutResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerAboutResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.Build.Set {
			e.FieldStart("build")
			s.Build.Encode(e)
		}
	}
	{
		if s.BuildImage.Set {
			e.FieldStart("buildImage")
			s.BuildImage.Encode(e)
		}
	}
	{
		if s.BuildImageUrl.Set {
			e.FieldStart("buildImageUrl")
			s.BuildImageUrl.Encode(e)
		}
	}
	{
		if s.BuildUrl.Set {
			e.FieldStart("buildUrl")
			s.BuildUrl.Encode(e)
		}
	}
	{
		if s.Exiftool.Set {
			e.FieldStart("exiftool")
			s.Exiftool.Encode(e)
		}
	}
	{
		if s.Ffmpeg.Set {
			e.FieldStart("ffmpeg")
			s.Ffmpeg.Encode(e)
		}
	}
	{
		if s.Imagemagick.Set {
			e.FieldStart("imagemagick")
			s.Imagemagick.Encode(e)
		}
	}
	{
		if s.Libvips.Set {
			e.FieldStart("libvips")
			s.Libvips.Encode(e)
		}
	}
	{
		e.FieldStart("licensed")
		e.Bool(s.Licensed)
	}
	{
		if s.Nodejs.Set {
			e.FieldStart("nodejs")
			s.Nodejs.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.FieldStart("repository")
			s.Repository.Encode(e)
		}
	}
	{
		if s.RepositoryUrl.Set {
			e.FieldStart("repositoryUrl")
			s.RepositoryUrl.Encode(e)
		}
	}
	{
		if s.SourceCommit.Set {
			e.FieldStart("sourceCommit")
			s.SourceCommit.Encode(e)
		}
	}
	{
		if s.SourceRef.Set {
			e.FieldStart("sourceRef")
			s.SourceRef.Encode(e)
		}
	}
	{
		if s.SourceUrl.Set {
			e.FieldStart("sourceUrl")
			s.SourceUrl.Encode(e)
		}
	}
	{
		if s.ThirdPartyBugFeatureUrl.Set {
			e.FieldStart("thirdPartyBugFeatureUrl")
			s.ThirdPartyBugFeatureUrl.Encode(e)
		}
	}
	{
		if s.ThirdPartyDocumentationUrl.Set {
			e.FieldStart("thirdPartyDocumentationUrl")
			s.ThirdPartyDocumentationUrl.Encode(e)
		}
	}
	{
		if s.ThirdPartySourceUrl.Set {
			e.FieldStart("thirdPartySourceUrl")
			s.ThirdPartySourceUrl.Encode(e)
		}
	}
	{
		if s.ThirdPartySupportUrl.Set {
			e.FieldStart("thirdPartySupportUrl")
			s.ThirdPartySupportUrl.Encode(e)
		}
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("versionUrl")
		e.Str(s.VersionUrl)
	}
}

var jsonFieldsNameOfServerAboutResponseDto = [21]string{
	0:  "build",
	1:  "buildImage",
	2:  "buildImageUrl",
	3:  "buildUrl",
	4:  "exiftool",
	5:  "ffmpeg",
	6:  "imagemagick",
	7:  "libvips",
	8:  "licensed",
	9:  "nodejs",
	10: "repository",
	11: "repositoryUrl",
	12: "sourceCommit",
	13: "sourceRef",
	14: "sourceUrl",
	15: "thirdPartyBugFeatureUrl",
	16: "thirdPartyDocumentationUrl",
	17: "thirdPartySourceUrl",
	18: "thirdPartySupportUrl",
	19: "version",
	20: "versionUrl",
}

// Decode decodes ServerAboutResponseDto from json.
func (s *ServerAboutResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerAboutResponseDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "build":
			if err := func() error {
				s.Build.Reset()
				if err := s.Build.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"build\"")
			}
		case "buildImage":
			if err := func() error {
				s.BuildImage.Reset()
				if err := s.BuildImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buildImage\"")
			}
		case "buildImageUrl":
			if err := func() error {
				s.BuildImageUrl.Reset()
				if err := s.BuildImageUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buildImageUrl\"")
			}
		case "buildUrl":
			if err := func() error {
				s.BuildUrl.Reset()
				if err := s.BuildUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buildUrl\"")
			}
		case "exiftool":
			if err := func() error {
				s.Exiftool.Reset()
				if err := s.Exiftool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exiftool\"")
			}
		case "ffmpeg":
			if err := func() error {
				s.Ffmpeg.Reset()
				if err := s.Ffmpeg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ffmpeg\"")
			}
		case "imagemagick":
			if err := func() error {
				s.Imagemagick.Reset()
				if err := s.Imagemagick.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagemagick\"")
			}
		case "libvips":
			if err := func() error {
				s.Libvips.Reset()
				if err := s.Libvips.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"libvips\"")
			}
		case "licensed":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Licensed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licensed\"")
			}
		case "nodejs":
			if err := func() error {
				s.Nodejs.Reset()
				if err := s.Nodejs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodejs\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "repositoryUrl":
			if err := func() error {
				s.RepositoryUrl.Reset()
				if err := s.RepositoryUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositoryUrl\"")
			}
		case "sourceCommit":
			if err := func() error {
				s.SourceCommit.Reset()
				if err := s.SourceCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceCommit\"")
			}
		case "sourceRef":
			if err := func() error {
				s.SourceRef.Reset()
				if err := s.SourceRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceRef\"")
			}
		case "sourceUrl":
			if err := func() error {
				s.SourceUrl.Reset()
				if err := s.SourceUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceUrl\"")
			}
		case "thirdPartyBugFeatureUrl":
			if err := func() error {
				s.ThirdPartyBugFeatureUrl.Reset()
				if err := s.ThirdPartyBugFeatureUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thirdPartyBugFeatureUrl\"")
			}
		case "thirdPartyDocumentationUrl":
			if err := func() error {
				s.ThirdPartyDocumentationUrl.Reset()
				if err := s.ThirdPartyDocumentationUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thirdPartyDocumentationUrl\"")
			}
		case "thirdPartySourceUrl":
			if err := func() error {
				s.ThirdPartySourceUrl.Reset()
				if err := s.ThirdPartySourceUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thirdPartySourceUrl\"")
			}
		case "thirdPartySupportUrl":
			if err := func() error {
				s.ThirdPartySupportUrl.Reset()
				if err := s.ThirdPartySupportUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thirdPartySupportUrl\"")
			}
		case "version":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "versionUrl":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VersionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerAboutResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000001,
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerAboutResponseDto) {
					name = jsonFieldsNameOfServerAboutResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerAboutResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerAboutResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerApkLinksDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerApkLinksDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("arm64v8a")
		e.Str(s.Arm64v8a)
	}
	{
		e.FieldStart("armeabiv7a")
		e.Str(s.Armeabiv7a)
	}
	{
		e.FieldStart("universal")
		e.Str(s.Universal)
	}
	{
		e.FieldStart("x86_64")
		e.Str(s.X8664)
	}
}

var jsonFieldsNameOfServerApkLinksDto = [4]string{
	0: "arm64v8a",
	1: "armeabiv7a",
	2: "universal",
	3: "x86_64",
}

// Decode decodes ServerApkLinksDto from json.
func (s *ServerApkLinksDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerApkLinksDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "arm64v8a":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Arm64v8a = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arm64v8a\"")
			}
		case "armeabiv7a":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Armeabiv7a = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armeabiv7a\"")
			}
		case "universal":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Universal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"universal\"")
			}
		case "x86_64":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.X8664 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x86_64\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerApkLinksDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerApkLinksDto) {
					name = jsonFieldsNameOfServerApkLinksDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerApkLinksDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerApkLinksDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerConfigDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerConfigDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("externalDomain")
		e.Str(s.ExternalDomain)
	}
	{
		e.FieldStart("isInitialized")
		e.Bool(s.IsInitialized)
	}
	{
		e.FieldStart("isOnboarded")
		e.Bool(s.IsOnboarded)
	}
	{
		e.FieldStart("loginPageMessage")
		e.Str(s.LoginPageMessage)
	}
	{
		e.FieldStart("mapDarkStyleUrl")
		e.Str(s.MapDarkStyleUrl)
	}
	{
		e.FieldStart("mapLightStyleUrl")
		e.Str(s.MapLightStyleUrl)
	}
	{
		e.FieldStart("oauthButtonText")
		e.Str(s.OauthButtonText)
	}
	{
		e.FieldStart("publicUsers")
		e.Bool(s.PublicUsers)
	}
	{
		e.FieldStart("trashDays")
		e.Int(s.TrashDays)
	}
	{
		e.FieldStart("userDeleteDelay")
		e.Int(s.UserDeleteDelay)
	}
}

var jsonFieldsNameOfServerConfigDto = [10]string{
	0: "externalDomain",
	1: "isInitialized",
	2: "isOnboarded",
	3: "loginPageMessage",
	4: "mapDarkStyleUrl",
	5: "mapLightStyleUrl",
	6: "oauthButtonText",
	7: "publicUsers",
	8: "trashDays",
	9: "userDeleteDelay",
}

// Decode decodes ServerConfigDto from json.
func (s *ServerConfigDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerConfigDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "externalDomain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExternalDomain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDomain\"")
			}
		case "isInitialized":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsInitialized = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isInitialized\"")
			}
		case "isOnboarded":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboarded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOnboarded\"")
			}
		case "loginPageMessage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LoginPageMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginPageMessage\"")
			}
		case "mapDarkStyleUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.MapDarkStyleUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapDarkStyleUrl\"")
			}
		case "mapLightStyleUrl":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.MapLightStyleUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapLightStyleUrl\"")
			}
		case "oauthButtonText":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.OauthButtonText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauthButtonText\"")
			}
		case "publicUsers":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.PublicUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicUsers\"")
			}
		case "trashDays":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TrashDays = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashDays\"")
			}
		case "userDeleteDelay":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UserDeleteDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userDeleteDelay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerConfigDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerConfigDto) {
					name = jsonFieldsNameOfServerConfigDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerConfigDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerConfigDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerFeaturesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerFeaturesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configFile")
		e.Bool(s.ConfigFile)
	}
	{
		e.FieldStart("duplicateDetection")
		e.Bool(s.DuplicateDetection)
	}
	{
		e.FieldStart("email")
		e.Bool(s.Email)
	}
	{
		e.FieldStart("facialRecognition")
		e.Bool(s.FacialRecognition)
	}
	{
		e.FieldStart("importFaces")
		e.Bool(s.ImportFaces)
	}
	{
		e.FieldStart("map")
		e.Bool(s.Map)
	}
	{
		e.FieldStart("oauth")
		e.Bool(s.OAuth)
	}
	{
		e.FieldStart("oauthAutoLaunch")
		e.Bool(s.OauthAutoLaunch)
	}
	{
		e.FieldStart("passwordLogin")
		e.Bool(s.PasswordLogin)
	}
	{
		e.FieldStart("reverseGeocoding")
		e.Bool(s.ReverseGeocoding)
	}
	{
		e.FieldStart("search")
		e.Bool(s.Search)
	}
	{
		e.FieldStart("sidecar")
		e.Bool(s.Sidecar)
	}
	{
		e.FieldStart("smartSearch")
		e.Bool(s.SmartSearch)
	}
	{
		e.FieldStart("trash")
		e.Bool(s.Trash)
	}
}

var jsonFieldsNameOfServerFeaturesDto = [14]string{
	0:  "configFile",
	1:  "duplicateDetection",
	2:  "email",
	3:  "facialRecognition",
	4:  "importFaces",
	5:  "map",
	6:  "oauth",
	7:  "oauthAutoLaunch",
	8:  "passwordLogin",
	9:  "reverseGeocoding",
	10: "search",
	11: "sidecar",
	12: "smartSearch",
	13: "trash",
}

// Decode decodes ServerFeaturesDto from json.
func (s *ServerFeaturesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerFeaturesDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configFile":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ConfigFile = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configFile\"")
			}
		case "duplicateDetection":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.DuplicateDetection = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateDetection\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Email = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "facialRecognition":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.FacialRecognition = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facialRecognition\"")
			}
		case "importFaces":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.ImportFaces = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importFaces\"")
			}
		case "map":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Map = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "oauth":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.OAuth = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth\"")
			}
		case "oauthAutoLaunch":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.OauthAutoLaunch = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauthAutoLaunch\"")
			}
		case "passwordLogin":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.PasswordLogin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordLogin\"")
			}
		case "reverseGeocoding":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ReverseGeocoding = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reverseGeocoding\"")
			}
		case "search":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Search = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search\"")
			}
		case "sidecar":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Sidecar = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidecar\"")
			}
		case "smartSearch":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.SmartSearch = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smartSearch\"")
			}
		case "trash":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Trash = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerFeaturesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerFeaturesDto) {
					name = jsonFieldsNameOfServerFeaturesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerFeaturesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerFeaturesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerMediaTypesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerMediaTypesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("image")
		e.ArrStart()
		for _, elem := range s.Image {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("sidecar")
		e.ArrStart()
		for _, elem := range s.Sidecar {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("video")
		e.ArrStart()
		for _, elem := range s.Video {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfServerMediaTypesResponseDto = [3]string{
	0: "image",
	1: "sidecar",
	2: "video",
}

// Decode decodes ServerMediaTypesResponseDto from json.
func (s *ServerMediaTypesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerMediaTypesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "image":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Image = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Image = append(s.Image, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "sidecar":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Sidecar = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Sidecar = append(s.Sidecar, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidecar\"")
			}
		case "video":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Video = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Video = append(s.Video, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerMediaTypesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerMediaTypesResponseDto) {
					name = jsonFieldsNameOfServerMediaTypesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerMediaTypesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerMediaTypesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerPingResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerPingResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("res")
		e.Str(s.Res)
	}
}

var jsonFieldsNameOfServerPingResponse = [1]string{
	0: "res",
}

// Decode decodes ServerPingResponse from json.
func (s *ServerPingResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerPingResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "res":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Res = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerPingResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerPingResponse) {
					name = jsonFieldsNameOfServerPingResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerPingResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerPingResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("photos")
		e.Int(s.Photos)
	}
	{
		e.FieldStart("usage")
		e.Int64(s.Usage)
	}
	{
		e.FieldStart("usageByUser")
		e.ArrStart()
		for _, elem := range s.UsageByUser {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("usagePhotos")
		e.Int64(s.UsagePhotos)
	}
	{
		e.FieldStart("usageVideos")
		e.Int64(s.UsageVideos)
	}
	{
		e.FieldStart("videos")
		e.Int(s.Videos)
	}
}

var jsonFieldsNameOfServerStatsResponseDto = [6]string{
	0: "photos",
	1: "usage",
	2: "usageByUser",
	3: "usagePhotos",
	4: "usageVideos",
	5: "videos",
}

// Decode decodes ServerStatsResponseDto from json.
func (s *ServerStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "photos":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Photos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photos\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Usage = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "usageByUser":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.UsageByUser = make([]UsageByUserDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsageByUserDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UsageByUser = append(s.UsageByUser, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageByUser\"")
			}
		case "usagePhotos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.UsagePhotos = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usagePhotos\"")
			}
		case "usageVideos":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.UsageVideos = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageVideos\"")
			}
		case "videos":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Videos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerStatsResponseDto) {
					name = jsonFieldsNameOfServerStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerStorageResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerStorageResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("diskAvailable")
		e.Str(s.DiskAvailable)
	}
	{
		e.FieldStart("diskAvailableRaw")
		e.Int64(s.DiskAvailableRaw)
	}
	{
		e.FieldStart("diskSize")
		e.Str(s.DiskSize)
	}
	{
		e.FieldStart("diskSizeRaw")
		e.Int64(s.DiskSizeRaw)
	}
	{
		e.FieldStart("diskUsagePercentage")
		e.Float64(s.DiskUsagePercentage)
	}
	{
		e.FieldStart("diskUse")
		e.Str(s.DiskUse)
	}
	{
		e.FieldStart("diskUseRaw")
		e.Int64(s.DiskUseRaw)
	}
}

var jsonFieldsNameOfServerStorageResponseDto = [7]string{
	0: "diskAvailable",
	1: "diskAvailableRaw",
	2: "diskSize",
	3: "diskSizeRaw",
	4: "diskUsagePercentage",
	5: "diskUse",
	6: "diskUseRaw",
}

// Decode decodes ServerStorageResponseDto from json.
func (s *ServerStorageResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerStorageResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "diskAvailable":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DiskAvailable = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskAvailable\"")
			}
		case "diskAvailableRaw":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.DiskAvailableRaw = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskAvailableRaw\"")
			}
		case "diskSize":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DiskSize = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskSize\"")
			}
		case "diskSizeRaw":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.DiskSizeRaw = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskSizeRaw\"")
			}
		case "diskUsagePercentage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.DiskUsagePercentage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskUsagePercentage\"")
			}
		case "diskUse":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DiskUse = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskUse\"")
			}
		case "diskUseRaw":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.DiskUseRaw = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskUseRaw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerStorageResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerStorageResponseDto) {
					name = jsonFieldsNameOfServerStorageResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerStorageResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerStorageResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerThemeDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerThemeDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("customCss")
		e.Str(s.CustomCss)
	}
}

var jsonFieldsNameOfServerThemeDto = [1]string{
	0: "customCss",
}

// Decode decodes ServerThemeDto from json.
func (s *ServerThemeDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerThemeDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "customCss":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomCss = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customCss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerThemeDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerThemeDto) {
					name = jsonFieldsNameOfServerThemeDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerThemeDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerThemeDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerVersionHistoryResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerVersionHistoryResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfServerVersionHistoryResponseDto = [3]string{
	0: "createdAt",
	1: "id",
	2: "version",
}

// Decode decodes ServerVersionHistoryResponseDto from json.
func (s *ServerVersionHistoryResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerVersionHistoryResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerVersionHistoryResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerVersionHistoryResponseDto) {
					name = jsonFieldsNameOfServerVersionHistoryResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerVersionHistoryResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerVersionHistoryResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerVersionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerVersionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("major")
		e.Int(s.Major)
	}
	{
		e.FieldStart("minor")
		e.Int(s.Minor)
	}
	{
		e.FieldStart("patch")
		e.Int(s.Patch)
	}
}

var jsonFieldsNameOfServerVersionResponseDto = [3]string{
	0: "major",
	1: "minor",
	2: "patch",
}

// Decode decodes ServerVersionResponseDto from json.
func (s *ServerVersionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerVersionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "major":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Major = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"major\"")
			}
		case "minor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Minor = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minor\"")
			}
		case "patch":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Patch = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerVersionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerVersionResponseDto) {
					name = jsonFieldsNameOfServerVersionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerVersionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerVersionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.DeviceOS.Set {
			e.FieldStart("deviceOS")
			s.DeviceOS.Encode(e)
		}
	}
	{
		if s.DeviceType.Set {
			e.FieldStart("deviceType")
			s.DeviceType.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionCreateDto = [3]string{
	0: "deviceOS",
	1: "deviceType",
	2: "duration",
}

// Decode decodes SessionCreateDto from json.
func (s *SessionCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deviceOS":
			if err := func() error {
				s.DeviceOS.Reset()
				if err := s.DeviceOS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceOS\"")
			}
		case "deviceType":
			if err := func() error {
				s.DeviceType.Reset()
				if err := s.DeviceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceType\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionCreateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionCreateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionCreateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("current")
		e.Bool(s.Current)
	}
	{
		e.FieldStart("deviceOS")
		e.Str(s.DeviceOS)
	}
	{
		e.FieldStart("deviceType")
		e.Str(s.DeviceType)
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expiresAt")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isPendingSyncReset")
		e.Bool(s.IsPendingSyncReset)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfSessionCreateResponseDto = [9]string{
	0: "createdAt",
	1: "current",
	2: "deviceOS",
	3: "deviceType",
	4: "expiresAt",
	5: "id",
	6: "isPendingSyncReset",
	7: "token",
	8: "updatedAt",
}

// Decode decodes SessionCreateResponseDto from json.
func (s *SessionCreateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "current":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Current = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "deviceOS":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DeviceOS = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceOS\"")
			}
		case "deviceType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DeviceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceType\"")
			}
		case "expiresAt":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isPendingSyncReset":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsPendingSyncReset = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPendingSyncReset\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionCreateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionCreateResponseDto) {
					name = jsonFieldsNameOfSessionCreateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionCreateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("current")
		e.Bool(s.Current)
	}
	{
		e.FieldStart("deviceOS")
		e.Str(s.DeviceOS)
	}
	{
		e.FieldStart("deviceType")
		e.Str(s.DeviceType)
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expiresAt")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isPendingSyncReset")
		e.Bool(s.IsPendingSyncReset)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfSessionResponseDto = [8]string{
	0: "createdAt",
	1: "current",
	2: "deviceOS",
	3: "deviceType",
	4: "expiresAt",
	5: "id",
	6: "isPendingSyncReset",
	7: "updatedAt",
}

// Decode decodes SessionResponseDto from json.
func (s *SessionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "current":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Current = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "deviceOS":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DeviceOS = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceOS\"")
			}
		case "deviceType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DeviceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceType\"")
			}
		case "expiresAt":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isPendingSyncReset":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsPendingSyncReset = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPendingSyncReset\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionResponseDto) {
					name = jsonFieldsNameOfSessionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionUnlockDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionUnlockDto) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PinCode.Set {
			e.FieldStart("pinCode")
			s.PinCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionUnlockDto = [2]string{
	0: "password",
	1: "pinCode",
}

// Decode decodes SessionUnlockDto from json.
func (s *SessionUnlockDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionUnlockDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "pinCode":
			if err := func() error {
				s.PinCode.Reset()
				if err := s.PinCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionUnlockDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionUnlockDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionUnlockDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.IsPendingSyncReset.Set {
			e.FieldStart("isPendingSyncReset")
			s.IsPendingSyncReset.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionUpdateDto = [1]string{
	0: "isPendingSyncReset",
}

// Decode decodes SessionUpdateDto from json.
func (s *SessionUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isPendingSyncReset":
			if err := func() error {
				s.IsPendingSyncReset.Reset()
				if err := s.IsPendingSyncReset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPendingSyncReset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedLinkCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedLinkCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumId.Set {
			e.FieldStart("albumId")
			s.AlbumId.Encode(e)
		}
	}
	{
		if s.AllowDownload.Set {
			e.FieldStart("allowDownload")
			s.AllowDownload.Encode(e)
		}
	}
	{
		if s.AllowUpload.Set {
			e.FieldStart("allowUpload")
			s.AllowUpload.Encode(e)
		}
	}
	{
		if s.AssetIds != nil {
			e.FieldStart("assetIds")
			e.ArrStart()
			for _, elem := range s.AssetIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expiresAt")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.ShowMetadata.Set {
			e.FieldStart("showMetadata")
			s.ShowMetadata.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfSharedLinkCreateDto = [10]string{
	0: "albumId",
	1: "allowDownload",
	2: "allowUpload",
	3: "assetIds",
	4: "description",
	5: "expiresAt",
	6: "password",
	7: "showMetadata",
	8: "slug",
	9: "type",
}

// Decode decodes SharedLinkCreateDto from json.
func (s *SharedLinkCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedLinkCreateDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumId":
			if err := func() error {
				s.AlbumId.Reset()
				if err := s.AlbumId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumId\"")
			}
		case "allowDownload":
			if err := func() error {
				s.AllowDownload.Reset()
				if err := s.AllowDownload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowDownload\"")
			}
		case "allowUpload":
			if err := func() error {
				s.AllowUpload.Reset()
				if err := s.AllowUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowUpload\"")
			}
		case "assetIds":
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "expiresAt":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "showMetadata":
			if err := func() error {
				s.ShowMetadata.Reset()
				if err := s.ShowMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"showMetadata\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedLinkCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSharedLinkCreateDto) {
					name = jsonFieldsNameOfSharedLinkCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedLinkCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedLinkCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedLinkEditDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedLinkEditDto) encodeFields(e *jx.Encoder) {
	{
		if s.AllowDownload.Set {
			e.FieldStart("allowDownload")
			s.AllowDownload.Encode(e)
		}
	}
	{
		if s.AllowUpload.Set {
			e.FieldStart("allowUpload")
			s.AllowUpload.Encode(e)
		}
	}
	{
		if s.ChangeExpiryTime.Set {
			e.FieldStart("changeExpiryTime")
			s.ChangeExpiryTime.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expiresAt")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.ShowMetadata.Set {
			e.FieldStart("showMetadata")
			s.ShowMetadata.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
}

var jsonFieldsNameOfSharedLinkEditDto = [8]string{
	0: "allowDownload",
	1: "allowUpload",
	2: "changeExpiryTime",
	3: "description",
	4: "expiresAt",
	5: "password",
	6: "showMetadata",
	7: "slug",
}

// Decode decodes SharedLinkEditDto from json.
func (s *SharedLinkEditDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedLinkEditDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowDownload":
			if err := func() error {
				s.AllowDownload.Reset()
				if err := s.AllowDownload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowDownload\"")
			}
		case "allowUpload":
			if err := func() error {
				s.AllowUpload.Reset()
				if err := s.AllowUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowUpload\"")
			}
		case "changeExpiryTime":
			if err := func() error {
				s.ChangeExpiryTime.Reset()
				if err := s.ChangeExpiryTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changeExpiryTime\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "expiresAt":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "showMetadata":
			if err := func() error {
				s.ShowMetadata.Reset()
				if err := s.ShowMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"showMetadata\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedLinkEditDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedLinkEditDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedLinkEditDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedLinkResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedLinkResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.Album.Set {
			e.FieldStart("album")
			s.Album.Encode(e)
		}
	}
	{
		e.FieldStart("allowDownload")
		e.Bool(s.AllowDownload)
	}
	{
		e.FieldStart("allowUpload")
		e.Bool(s.AllowUpload)
	}
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("expiresAt")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("password")
		s.Password.Encode(e)
	}
	{
		e.FieldStart("showMetadata")
		e.Bool(s.ShowMetadata)
	}
	{
		e.FieldStart("slug")
		s.Slug.Encode(e)
	}
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
}

var jsonFieldsNameOfSharedLinkResponseDto = [15]string{
	0:  "album",
	1:  "allowDownload",
	2:  "allowUpload",
	3:  "assets",
	4:  "createdAt",
	5:  "description",
	6:  "expiresAt",
	7:  "id",
	8:  "key",
	9:  "password",
	10: "showMetadata",
	11: "slug",
	12: "token",
	13: "type",
	14: "userId",
}

// Decode decodes SharedLinkResponseDto from json.
func (s *SharedLinkResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedLinkResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "album":
			if err := func() error {
				s.Album.Reset()
				if err := s.Album.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"album\"")
			}
		case "allowDownload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.AllowDownload = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowDownload\"")
			}
		case "allowUpload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.AllowUpload = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowUpload\"")
			}
		case "assets":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Assets = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "password":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "showMetadata":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.ShowMetadata = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"showMetadata\"")
			}
		case "slug":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "userId":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedLinkResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111110,
		0b01101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSharedLinkResponseDto) {
					name = jsonFieldsNameOfSharedLinkResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedLinkResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedLinkResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SharedLinkType as json.
func (s SharedLinkType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SharedLinkType from json.
func (s *SharedLinkType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedLinkType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SharedLinkType(v) {
	case SharedLinkTypeALBUM:
		*s = SharedLinkTypeALBUM
	case SharedLinkTypeINDIVIDUAL:
		*s = SharedLinkTypeINDIVIDUAL
	default:
		*s = SharedLinkType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SharedLinkType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedLinkType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedLinksResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedLinksResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("sidebarWeb")
		e.Bool(s.SidebarWeb)
	}
}

var jsonFieldsNameOfSharedLinksResponse = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes SharedLinksResponse from json.
func (s *SharedLinksResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedLinksResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SidebarWeb = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedLinksResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSharedLinksResponse) {
					name = jsonFieldsNameOfSharedLinksResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedLinksResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedLinksResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedLinksUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedLinksUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.SidebarWeb.Set {
			e.FieldStart("sidebarWeb")
			s.SidebarWeb.Encode(e)
		}
	}
}

var jsonFieldsNameOfSharedLinksUpdate = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes SharedLinksUpdate from json.
func (s *SharedLinksUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedLinksUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			if err := func() error {
				s.SidebarWeb.Reset()
				if err := s.SidebarWeb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedLinksUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedLinksUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedLinksUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SignUpDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SignUpDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfSignUpDto = [3]string{
	0: "email",
	1: "name",
	2: "password",
}

// Decode decodes SignUpDto from json.
func (s *SignUpDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignUpDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SignUpDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSignUpDto) {
					name = jsonFieldsNameOfSignUpDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SignUpDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignUpDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SmartSearchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SmartSearchDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumIds != nil {
			e.FieldStart("albumIds")
			e.ArrStart()
			for _, elem := range s.AlbumIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.City.Set {
			e.FieldStart("city")
			s.City.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.CreatedAfter.Set {
			e.FieldStart("createdAfter")
			s.CreatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBefore.Set {
			e.FieldStart("createdBefore")
			s.CreatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DeviceId.Set {
			e.FieldStart("deviceId")
			s.DeviceId.Encode(e)
		}
	}
	{
		if s.IsEncoded.Set {
			e.FieldStart("isEncoded")
			s.IsEncoded.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsMotion.Set {
			e.FieldStart("isMotion")
			s.IsMotion.Encode(e)
		}
	}
	{
		if s.IsNotInAlbum.Set {
			e.FieldStart("isNotInAlbum")
			s.IsNotInAlbum.Encode(e)
		}
	}
	{
		if s.IsOffline.Set {
			e.FieldStart("isOffline")
			s.IsOffline.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.LensModel.Set {
			e.FieldStart("lensModel")
			s.LensModel.Encode(e)
		}
	}
	{
		if s.LibraryId.Set {
			e.FieldStart("libraryId")
			s.LibraryId.Encode(e)
		}
	}
	{
		if s.Make.Set {
			e.FieldStart("make")
			s.Make.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PersonIds != nil {
			e.FieldStart("personIds")
			e.ArrStart()
			for _, elem := range s.PersonIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
	{
		if s.QueryAssetId.Set {
			e.FieldStart("queryAssetId")
			s.QueryAssetId.Encode(e)
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TagIds.Set {
			e.FieldStart("tagIds")
			s.TagIds.Encode(e)
		}
	}
	{
		if s.TakenAfter.Set {
			e.FieldStart("takenAfter")
			s.TakenAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TakenBefore.Set {
			e.FieldStart("takenBefore")
			s.TakenBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedAfter.Set {
			e.FieldStart("trashedAfter")
			s.TrashedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedBefore.Set {
			e.FieldStart("trashedBefore")
			s.TrashedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.UpdatedAfter.Set {
			e.FieldStart("updatedAfter")
			s.UpdatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBefore.Set {
			e.FieldStart("updatedBefore")
			s.UpdatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.WithDeleted.Set {
			e.FieldStart("withDeleted")
			s.WithDeleted.Encode(e)
		}
	}
	{
		if s.WithExif.Set {
			e.FieldStart("withExif")
			s.WithExif.Encode(e)
		}
	}
}

var jsonFieldsNameOfSmartSearchDto = [34]string{
	0:  "albumIds",
	1:  "city",
	2:  "country",
	3:  "createdAfter",
	4:  "createdBefore",
	5:  "deviceId",
	6:  "isEncoded",
	7:  "isFavorite",
	8:  "isMotion",
	9:  "isNotInAlbum",
	10: "isOffline",
	11: "language",
	12: "lensModel",
	13: "libraryId",
	14: "make",
	15: "model",
	16: "page",
	17: "personIds",
	18: "query",
	19: "queryAssetId",
	20: "rating",
	21: "size",
	22: "state",
	23: "tagIds",
	24: "takenAfter",
	25: "takenBefore",
	26: "trashedAfter",
	27: "trashedBefore",
	28: "type",
	29: "updatedAfter",
	30: "updatedBefore",
	31: "visibility",
	32: "withDeleted",
	33: "withExif",
}

// Decode decodes SmartSearchDto from json.
func (s *SmartSearchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SmartSearchDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumIds":
			if err := func() error {
				s.AlbumIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AlbumIds = append(s.AlbumIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumIds\"")
			}
		case "city":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "createdAfter":
			if err := func() error {
				s.CreatedAfter.Reset()
				if err := s.CreatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAfter\"")
			}
		case "createdBefore":
			if err := func() error {
				s.CreatedBefore.Reset()
				if err := s.CreatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBefore\"")
			}
		case "deviceId":
			if err := func() error {
				s.DeviceId.Reset()
				if err := s.DeviceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceId\"")
			}
		case "isEncoded":
			if err := func() error {
				s.IsEncoded.Reset()
				if err := s.IsEncoded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEncoded\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isMotion":
			if err := func() error {
				s.IsMotion.Reset()
				if err := s.IsMotion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMotion\"")
			}
		case "isNotInAlbum":
			if err := func() error {
				s.IsNotInAlbum.Reset()
				if err := s.IsNotInAlbum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNotInAlbum\"")
			}
		case "isOffline":
			if err := func() error {
				s.IsOffline.Reset()
				if err := s.IsOffline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOffline\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "lensModel":
			if err := func() error {
				s.LensModel.Reset()
				if err := s.LensModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lensModel\"")
			}
		case "libraryId":
			if err := func() error {
				s.LibraryId.Reset()
				if err := s.LibraryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"libraryId\"")
			}
		case "make":
			if err := func() error {
				s.Make.Reset()
				if err := s.Make.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"make\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "personIds":
			if err := func() error {
				s.PersonIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PersonIds = append(s.PersonIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personIds\"")
			}
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "queryAssetId":
			if err := func() error {
				s.QueryAssetId.Reset()
				if err := s.QueryAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryAssetId\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "tagIds":
			if err := func() error {
				s.TagIds.Reset()
				if err := s.TagIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagIds\"")
			}
		case "takenAfter":
			if err := func() error {
				s.TakenAfter.Reset()
				if err := s.TakenAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenAfter\"")
			}
		case "takenBefore":
			if err := func() error {
				s.TakenBefore.Reset()
				if err := s.TakenBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenBefore\"")
			}
		case "trashedAfter":
			if err := func() error {
				s.TrashedAfter.Reset()
				if err := s.TrashedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedAfter\"")
			}
		case "trashedBefore":
			if err := func() error {
				s.TrashedBefore.Reset()
				if err := s.TrashedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedBefore\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "updatedAfter":
			if err := func() error {
				s.UpdatedAfter.Reset()
				if err := s.UpdatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAfter\"")
			}
		case "updatedBefore":
			if err := func() error {
				s.UpdatedBefore.Reset()
				if err := s.UpdatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBefore\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "withDeleted":
			if err := func() error {
				s.WithDeleted.Reset()
				if err := s.WithDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withDeleted\"")
			}
		case "withExif":
			if err := func() error {
				s.WithExif.Reset()
				if err := s.WithExif.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withExif\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SmartSearchDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SmartSearchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SmartSearchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SourceType as json.
func (s SourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SourceType from json.
func (s *SourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SourceType(v) {
	case SourceTypeMachineLearning:
		*s = SourceTypeMachineLearning
	case SourceTypeExif:
		*s = SourceTypeExif
	case SourceTypeManual:
		*s = SourceTypeManual
	default:
		*s = SourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StackCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StackCreateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetIds")
		e.ArrStart()
		for _, elem := range s.AssetIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStackCreateDto = [1]string{
	0: "assetIds",
}

// Decode decodes StackCreateDto from json.
func (s *StackCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StackCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StackCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStackCreateDto) {
					name = jsonFieldsNameOfStackCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StackCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StackCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StackResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StackResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assets")
		e.ArrStart()
		for _, elem := range s.Assets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("primaryAssetId")
		e.Str(s.PrimaryAssetId)
	}
}

var jsonFieldsNameOfStackResponseDto = [3]string{
	0: "assets",
	1: "id",
	2: "primaryAssetId",
}

// Decode decodes StackResponseDto from json.
func (s *StackResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StackResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Assets = make([]AssetResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "primaryAssetId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PrimaryAssetId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryAssetId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StackResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStackResponseDto) {
					name = jsonFieldsNameOfStackResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StackResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StackResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StackUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StackUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.PrimaryAssetId.Set {
			e.FieldStart("primaryAssetId")
			s.PrimaryAssetId.Encode(e)
		}
	}
}

var jsonFieldsNameOfStackUpdateDto = [1]string{
	0: "primaryAssetId",
}

// Decode decodes StackUpdateDto from json.
func (s *StackUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StackUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "primaryAssetId":
			if err := func() error {
				s.PrimaryAssetId.Reset()
				if err := s.PrimaryAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryAssetId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StackUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StackUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StackUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatisticsSearchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatisticsSearchDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumIds != nil {
			e.FieldStart("albumIds")
			e.ArrStart()
			for _, elem := range s.AlbumIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.City.Set {
			e.FieldStart("city")
			s.City.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.CreatedAfter.Set {
			e.FieldStart("createdAfter")
			s.CreatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBefore.Set {
			e.FieldStart("createdBefore")
			s.CreatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DeviceId.Set {
			e.FieldStart("deviceId")
			s.DeviceId.Encode(e)
		}
	}
	{
		if s.IsEncoded.Set {
			e.FieldStart("isEncoded")
			s.IsEncoded.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.IsMotion.Set {
			e.FieldStart("isMotion")
			s.IsMotion.Encode(e)
		}
	}
	{
		if s.IsNotInAlbum.Set {
			e.FieldStart("isNotInAlbum")
			s.IsNotInAlbum.Encode(e)
		}
	}
	{
		if s.IsOffline.Set {
			e.FieldStart("isOffline")
			s.IsOffline.Encode(e)
		}
	}
	{
		if s.LensModel.Set {
			e.FieldStart("lensModel")
			s.LensModel.Encode(e)
		}
	}
	{
		if s.LibraryId.Set {
			e.FieldStart("libraryId")
			s.LibraryId.Encode(e)
		}
	}
	{
		if s.Make.Set {
			e.FieldStart("make")
			s.Make.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.PersonIds != nil {
			e.FieldStart("personIds")
			e.ArrStart()
			for _, elem := range s.PersonIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TagIds.Set {
			e.FieldStart("tagIds")
			s.TagIds.Encode(e)
		}
	}
	{
		if s.TakenAfter.Set {
			e.FieldStart("takenAfter")
			s.TakenAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TakenBefore.Set {
			e.FieldStart("takenBefore")
			s.TakenBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedAfter.Set {
			e.FieldStart("trashedAfter")
			s.TrashedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TrashedBefore.Set {
			e.FieldStart("trashedBefore")
			s.TrashedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.UpdatedAfter.Set {
			e.FieldStart("updatedAfter")
			s.UpdatedAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBefore.Set {
			e.FieldStart("updatedBefore")
			s.UpdatedBefore.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfStatisticsSearchDto = [28]string{
	0:  "albumIds",
	1:  "city",
	2:  "country",
	3:  "createdAfter",
	4:  "createdBefore",
	5:  "description",
	6:  "deviceId",
	7:  "isEncoded",
	8:  "isFavorite",
	9:  "isMotion",
	10: "isNotInAlbum",
	11: "isOffline",
	12: "lensModel",
	13: "libraryId",
	14: "make",
	15: "model",
	16: "personIds",
	17: "rating",
	18: "state",
	19: "tagIds",
	20: "takenAfter",
	21: "takenBefore",
	22: "trashedAfter",
	23: "trashedBefore",
	24: "type",
	25: "updatedAfter",
	26: "updatedBefore",
	27: "visibility",
}

// Decode decodes StatisticsSearchDto from json.
func (s *StatisticsSearchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatisticsSearchDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumIds":
			if err := func() error {
				s.AlbumIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AlbumIds = append(s.AlbumIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumIds\"")
			}
		case "city":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "createdAfter":
			if err := func() error {
				s.CreatedAfter.Reset()
				if err := s.CreatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAfter\"")
			}
		case "createdBefore":
			if err := func() error {
				s.CreatedBefore.Reset()
				if err := s.CreatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBefore\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "deviceId":
			if err := func() error {
				s.DeviceId.Reset()
				if err := s.DeviceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceId\"")
			}
		case "isEncoded":
			if err := func() error {
				s.IsEncoded.Reset()
				if err := s.IsEncoded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEncoded\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isMotion":
			if err := func() error {
				s.IsMotion.Reset()
				if err := s.IsMotion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMotion\"")
			}
		case "isNotInAlbum":
			if err := func() error {
				s.IsNotInAlbum.Reset()
				if err := s.IsNotInAlbum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNotInAlbum\"")
			}
		case "isOffline":
			if err := func() error {
				s.IsOffline.Reset()
				if err := s.IsOffline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOffline\"")
			}
		case "lensModel":
			if err := func() error {
				s.LensModel.Reset()
				if err := s.LensModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lensModel\"")
			}
		case "libraryId":
			if err := func() error {
				s.LibraryId.Reset()
				if err := s.LibraryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"libraryId\"")
			}
		case "make":
			if err := func() error {
				s.Make.Reset()
				if err := s.Make.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"make\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "personIds":
			if err := func() error {
				s.PersonIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.PersonIds = append(s.PersonIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"personIds\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "tagIds":
			if err := func() error {
				s.TagIds.Reset()
				if err := s.TagIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagIds\"")
			}
		case "takenAfter":
			if err := func() error {
				s.TakenAfter.Reset()
				if err := s.TakenAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenAfter\"")
			}
		case "takenBefore":
			if err := func() error {
				s.TakenBefore.Reset()
				if err := s.TakenBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takenBefore\"")
			}
		case "trashedAfter":
			if err := func() error {
				s.TrashedAfter.Reset()
				if err := s.TrashedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedAfter\"")
			}
		case "trashedBefore":
			if err := func() error {
				s.TrashedBefore.Reset()
				if err := s.TrashedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashedBefore\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "updatedAfter":
			if err := func() error {
				s.UpdatedAfter.Reset()
				if err := s.UpdatedAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAfter\"")
			}
		case "updatedBefore":
			if err := func() error {
				s.UpdatedBefore.Reset()
				if err := s.UpdatedBefore.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBefore\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatisticsSearchDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatisticsSearchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatisticsSearchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SyncAckDeleteDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SyncAckDeleteDto) encodeFields(e *jx.Encoder) {
	{
		if s.Types != nil {
			e.FieldStart("types")
			e.ArrStart()
			for _, elem := range s.Types {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSyncAckDeleteDto = [1]string{
	0: "types",
}

// Decode decodes SyncAckDeleteDto from json.
func (s *SyncAckDeleteDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncAckDeleteDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "types":
			if err := func() error {
				s.Types = make([]SyncEntityType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SyncEntityType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Types = append(s.Types, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SyncAckDeleteDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SyncAckDeleteDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncAckDeleteDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SyncAckDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SyncAckDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ack")
		e.Str(s.Ack)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfSyncAckDto = [2]string{
	0: "ack",
	1: "type",
}

// Decode decodes SyncAckDto from json.
func (s *SyncAckDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncAckDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ack":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ack = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ack\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SyncAckDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSyncAckDto) {
					name = jsonFieldsNameOfSyncAckDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SyncAckDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncAckDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SyncAckSetDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SyncAckSetDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("acks")
		e.ArrStart()
		for _, elem := range s.Acks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSyncAckSetDto = [1]string{
	0: "acks",
}

// Decode decodes SyncAckSetDto from json.
func (s *SyncAckSetDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncAckSetDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Acks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Acks = append(s.Acks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SyncAckSetDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSyncAckSetDto) {
					name = jsonFieldsNameOfSyncAckSetDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SyncAckSetDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncAckSetDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SyncEntityType as json.
func (s SyncEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SyncEntityType from json.
func (s *SyncEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SyncEntityType(v) {
	case SyncEntityTypeAuthUserV1:
		*s = SyncEntityTypeAuthUserV1
	case SyncEntityTypeUserV1:
		*s = SyncEntityTypeUserV1
	case SyncEntityTypeUserDeleteV1:
		*s = SyncEntityTypeUserDeleteV1
	case SyncEntityTypeAssetV1:
		*s = SyncEntityTypeAssetV1
	case SyncEntityTypeAssetDeleteV1:
		*s = SyncEntityTypeAssetDeleteV1
	case SyncEntityTypeAssetExifV1:
		*s = SyncEntityTypeAssetExifV1
	case SyncEntityTypeAssetMetadataV1:
		*s = SyncEntityTypeAssetMetadataV1
	case SyncEntityTypeAssetMetadataDeleteV1:
		*s = SyncEntityTypeAssetMetadataDeleteV1
	case SyncEntityTypePartnerV1:
		*s = SyncEntityTypePartnerV1
	case SyncEntityTypePartnerDeleteV1:
		*s = SyncEntityTypePartnerDeleteV1
	case SyncEntityTypePartnerAssetV1:
		*s = SyncEntityTypePartnerAssetV1
	case SyncEntityTypePartnerAssetBackfillV1:
		*s = SyncEntityTypePartnerAssetBackfillV1
	case SyncEntityTypePartnerAssetDeleteV1:
		*s = SyncEntityTypePartnerAssetDeleteV1
	case SyncEntityTypePartnerAssetExifV1:
		*s = SyncEntityTypePartnerAssetExifV1
	case SyncEntityTypePartnerAssetExifBackfillV1:
		*s = SyncEntityTypePartnerAssetExifBackfillV1
	case SyncEntityTypePartnerStackBackfillV1:
		*s = SyncEntityTypePartnerStackBackfillV1
	case SyncEntityTypePartnerStackDeleteV1:
		*s = SyncEntityTypePartnerStackDeleteV1
	case SyncEntityTypePartnerStackV1:
		*s = SyncEntityTypePartnerStackV1
	case SyncEntityTypeAlbumV1:
		*s = SyncEntityTypeAlbumV1
	case SyncEntityTypeAlbumDeleteV1:
		*s = SyncEntityTypeAlbumDeleteV1
	case SyncEntityTypeAlbumUserV1:
		*s = SyncEntityTypeAlbumUserV1
	case SyncEntityTypeAlbumUserBackfillV1:
		*s = SyncEntityTypeAlbumUserBackfillV1
	case SyncEntityTypeAlbumUserDeleteV1:
		*s = SyncEntityTypeAlbumUserDeleteV1
	case SyncEntityTypeAlbumAssetCreateV1:
		*s = SyncEntityTypeAlbumAssetCreateV1
	case SyncEntityTypeAlbumAssetUpdateV1:
		*s = SyncEntityTypeAlbumAssetUpdateV1
	case SyncEntityTypeAlbumAssetBackfillV1:
		*s = SyncEntityTypeAlbumAssetBackfillV1
	case SyncEntityTypeAlbumAssetExifCreateV1:
		*s = SyncEntityTypeAlbumAssetExifCreateV1
	case SyncEntityTypeAlbumAssetExifUpdateV1:
		*s = SyncEntityTypeAlbumAssetExifUpdateV1
	case SyncEntityTypeAlbumAssetExifBackfillV1:
		*s = SyncEntityTypeAlbumAssetExifBackfillV1
	case SyncEntityTypeAlbumToAssetV1:
		*s = SyncEntityTypeAlbumToAssetV1
	case SyncEntityTypeAlbumToAssetDeleteV1:
		*s = SyncEntityTypeAlbumToAssetDeleteV1
	case SyncEntityTypeAlbumToAssetBackfillV1:
		*s = SyncEntityTypeAlbumToAssetBackfillV1
	case SyncEntityTypeMemoryV1:
		*s = SyncEntityTypeMemoryV1
	case SyncEntityTypeMemoryDeleteV1:
		*s = SyncEntityTypeMemoryDeleteV1
	case SyncEntityTypeMemoryToAssetV1:
		*s = SyncEntityTypeMemoryToAssetV1
	case SyncEntityTypeMemoryToAssetDeleteV1:
		*s = SyncEntityTypeMemoryToAssetDeleteV1
	case SyncEntityTypeStackV1:
		*s = SyncEntityTypeStackV1
	case SyncEntityTypeStackDeleteV1:
		*s = SyncEntityTypeStackDeleteV1
	case SyncEntityTypePersonV1:
		*s = SyncEntityTypePersonV1
	case SyncEntityTypePersonDeleteV1:
		*s = SyncEntityTypePersonDeleteV1
	case SyncEntityTypeAssetFaceV1:
		*s = SyncEntityTypeAssetFaceV1
	case SyncEntityTypeAssetFaceDeleteV1:
		*s = SyncEntityTypeAssetFaceDeleteV1
	case SyncEntityTypeUserMetadataV1:
		*s = SyncEntityTypeUserMetadataV1
	case SyncEntityTypeUserMetadataDeleteV1:
		*s = SyncEntityTypeUserMetadataDeleteV1
	case SyncEntityTypeSyncAckV1:
		*s = SyncEntityTypeSyncAckV1
	case SyncEntityTypeSyncResetV1:
		*s = SyncEntityTypeSyncResetV1
	case SyncEntityTypeSyncCompleteV1:
		*s = SyncEntityTypeSyncCompleteV1
	default:
		*s = SyncEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SyncEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SyncRequestType as json.
func (s SyncRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SyncRequestType from json.
func (s *SyncRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SyncRequestType(v) {
	case SyncRequestTypeAlbumsV1:
		*s = SyncRequestTypeAlbumsV1
	case SyncRequestTypeAlbumUsersV1:
		*s = SyncRequestTypeAlbumUsersV1
	case SyncRequestTypeAlbumToAssetsV1:
		*s = SyncRequestTypeAlbumToAssetsV1
	case SyncRequestTypeAlbumAssetsV1:
		*s = SyncRequestTypeAlbumAssetsV1
	case SyncRequestTypeAlbumAssetExifsV1:
		*s = SyncRequestTypeAlbumAssetExifsV1
	case SyncRequestTypeAssetsV1:
		*s = SyncRequestTypeAssetsV1
	case SyncRequestTypeAssetExifsV1:
		*s = SyncRequestTypeAssetExifsV1
	case SyncRequestTypeAssetMetadataV1:
		*s = SyncRequestTypeAssetMetadataV1
	case SyncRequestTypeAuthUsersV1:
		*s = SyncRequestTypeAuthUsersV1
	case SyncRequestTypeMemoriesV1:
		*s = SyncRequestTypeMemoriesV1
	case SyncRequestTypeMemoryToAssetsV1:
		*s = SyncRequestTypeMemoryToAssetsV1
	case SyncRequestTypePartnersV1:
		*s = SyncRequestTypePartnersV1
	case SyncRequestTypePartnerAssetsV1:
		*s = SyncRequestTypePartnerAssetsV1
	case SyncRequestTypePartnerAssetExifsV1:
		*s = SyncRequestTypePartnerAssetExifsV1
	case SyncRequestTypePartnerStacksV1:
		*s = SyncRequestTypePartnerStacksV1
	case SyncRequestTypeStacksV1:
		*s = SyncRequestTypeStacksV1
	case SyncRequestTypeUsersV1:
		*s = SyncRequestTypeUsersV1
	case SyncRequestTypePeopleV1:
		*s = SyncRequestTypePeopleV1
	case SyncRequestTypeAssetFacesV1:
		*s = SyncRequestTypeAssetFacesV1
	case SyncRequestTypeUserMetadataV1:
		*s = SyncRequestTypeUserMetadataV1
	default:
		*s = SyncRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SyncRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SyncStreamDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SyncStreamDto) encodeFields(e *jx.Encoder) {
	{
		if s.Reset.Set {
			e.FieldStart("reset")
			s.Reset.Encode(e)
		}
	}
	{
		e.FieldStart("types")
		e.ArrStart()
		for _, elem := range s.Types {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSyncStreamDto = [2]string{
	0: "reset",
	1: "types",
}

// Decode decodes SyncStreamDto from json.
func (s *SyncStreamDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SyncStreamDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reset":
			if err := func() error {
				s.Reset.Reset()
				if err := s.Reset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset\"")
			}
		case "types":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Types = make([]SyncRequestType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SyncRequestType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Types = append(s.Types, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SyncStreamDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSyncStreamDto) {
					name = jsonFieldsNameOfSyncStreamDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SyncStreamDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SyncStreamDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigBackupsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigBackupsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("database")
		s.Database.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigBackupsDto = [1]string{
	0: "database",
}

// Decode decodes SystemConfigBackupsDto from json.
func (s *SystemConfigBackupsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigBackupsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "database":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Database.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"database\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigBackupsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigBackupsDto) {
					name = jsonFieldsNameOfSystemConfigBackupsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigBackupsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigBackupsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backup")
		s.Backup.Encode(e)
	}
	{
		e.FieldStart("ffmpeg")
		s.Ffmpeg.Encode(e)
	}
	{
		e.FieldStart("image")
		s.Image.Encode(e)
	}
	{
		e.FieldStart("job")
		s.Job.Encode(e)
	}
	{
		e.FieldStart("library")
		s.Library.Encode(e)
	}
	{
		e.FieldStart("logging")
		s.Logging.Encode(e)
	}
	{
		e.FieldStart("machineLearning")
		s.MachineLearning.Encode(e)
	}
	{
		e.FieldStart("map")
		s.Map.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("newVersionCheck")
		s.NewVersionCheck.Encode(e)
	}
	{
		e.FieldStart("nightlyTasks")
		s.NightlyTasks.Encode(e)
	}
	{
		e.FieldStart("notifications")
		s.Notifications.Encode(e)
	}
	{
		e.FieldStart("oauth")
		s.OAuth.Encode(e)
	}
	{
		e.FieldStart("passwordLogin")
		s.PasswordLogin.Encode(e)
	}
	{
		e.FieldStart("reverseGeocoding")
		s.ReverseGeocoding.Encode(e)
	}
	{
		e.FieldStart("server")
		s.Server.Encode(e)
	}
	{
		e.FieldStart("storageTemplate")
		s.StorageTemplate.Encode(e)
	}
	{
		e.FieldStart("templates")
		s.Templates.Encode(e)
	}
	{
		e.FieldStart("theme")
		s.Theme.Encode(e)
	}
	{
		e.FieldStart("trash")
		s.Trash.Encode(e)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigDto = [21]string{
	0:  "backup",
	1:  "ffmpeg",
	2:  "image",
	3:  "job",
	4:  "library",
	5:  "logging",
	6:  "machineLearning",
	7:  "map",
	8:  "metadata",
	9:  "newVersionCheck",
	10: "nightlyTasks",
	11: "notifications",
	12: "oauth",
	13: "passwordLogin",
	14: "reverseGeocoding",
	15: "server",
	16: "storageTemplate",
	17: "templates",
	18: "theme",
	19: "trash",
	20: "user",
}

// Decode decodes SystemConfigDto from json.
func (s *SystemConfigDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Backup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup\"")
			}
		case "ffmpeg":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Ffmpeg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ffmpeg\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "job":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Job.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job\"")
			}
		case "library":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Library.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"library\"")
			}
		case "logging":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Logging.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logging\"")
			}
		case "machineLearning":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.MachineLearning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"machineLearning\"")
			}
		case "map":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Map.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "newVersionCheck":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.NewVersionCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"newVersionCheck\"")
			}
		case "nightlyTasks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.NightlyTasks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nightlyTasks\"")
			}
		case "notifications":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Notifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "oauth":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth\"")
			}
		case "passwordLogin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.PasswordLogin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordLogin\"")
			}
		case "reverseGeocoding":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ReverseGeocoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reverseGeocoding\"")
			}
		case "server":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Server.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		case "storageTemplate":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.StorageTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageTemplate\"")
			}
		case "templates":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Templates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "theme":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Theme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"theme\"")
			}
		case "trash":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Trash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trash\"")
			}
		case "user":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigDto) {
					name = jsonFieldsNameOfSystemConfigDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigFFmpegDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigFFmpegDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accel")
		s.Accel.Encode(e)
	}
	{
		e.FieldStart("accelDecode")
		e.Bool(s.AccelDecode)
	}
	{
		e.FieldStart("acceptedAudioCodecs")
		e.ArrStart()
		for _, elem := range s.AcceptedAudioCodecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("acceptedContainers")
		e.ArrStart()
		for _, elem := range s.AcceptedContainers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("acceptedVideoCodecs")
		e.ArrStart()
		for _, elem := range s.AcceptedVideoCodecs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("bframes")
		e.Int(s.Bframes)
	}
	{
		e.FieldStart("cqMode")
		s.CqMode.Encode(e)
	}
	{
		e.FieldStart("crf")
		e.Int(s.Crf)
	}
	{
		e.FieldStart("gopSize")
		e.Int(s.GopSize)
	}
	{
		e.FieldStart("maxBitrate")
		e.Str(s.MaxBitrate)
	}
	{
		e.FieldStart("preferredHwDevice")
		e.Str(s.PreferredHwDevice)
	}
	{
		e.FieldStart("preset")
		e.Str(s.Preset)
	}
	{
		e.FieldStart("refs")
		e.Int(s.Refs)
	}
	{
		e.FieldStart("targetAudioCodec")
		s.TargetAudioCodec.Encode(e)
	}
	{
		e.FieldStart("targetResolution")
		e.Str(s.TargetResolution)
	}
	{
		e.FieldStart("targetVideoCodec")
		s.TargetVideoCodec.Encode(e)
	}
	{
		e.FieldStart("temporalAQ")
		e.Bool(s.TemporalAQ)
	}
	{
		e.FieldStart("threads")
		e.Int(s.Threads)
	}
	{
		e.FieldStart("tonemap")
		s.Tonemap.Encode(e)
	}
	{
		e.FieldStart("transcode")
		s.Transcode.Encode(e)
	}
	{
		e.FieldStart("twoPass")
		e.Bool(s.TwoPass)
	}
}

var jsonFieldsNameOfSystemConfigFFmpegDto = [21]string{
	0:  "accel",
	1:  "accelDecode",
	2:  "acceptedAudioCodecs",
	3:  "acceptedContainers",
	4:  "acceptedVideoCodecs",
	5:  "bframes",
	6:  "cqMode",
	7:  "crf",
	8:  "gopSize",
	9:  "maxBitrate",
	10: "preferredHwDevice",
	11: "preset",
	12: "refs",
	13: "targetAudioCodec",
	14: "targetResolution",
	15: "targetVideoCodec",
	16: "temporalAQ",
	17: "threads",
	18: "tonemap",
	19: "transcode",
	20: "twoPass",
}

// Decode decodes SystemConfigFFmpegDto from json.
func (s *SystemConfigFFmpegDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigFFmpegDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accel":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Accel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accel\"")
			}
		case "accelDecode":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.AccelDecode = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accelDecode\"")
			}
		case "acceptedAudioCodecs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AcceptedAudioCodecs = make([]AudioCodec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AudioCodec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AcceptedAudioCodecs = append(s.AcceptedAudioCodecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptedAudioCodecs\"")
			}
		case "acceptedContainers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AcceptedContainers = make([]VideoContainer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VideoContainer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AcceptedContainers = append(s.AcceptedContainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptedContainers\"")
			}
		case "acceptedVideoCodecs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.AcceptedVideoCodecs = make([]VideoCodec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VideoCodec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AcceptedVideoCodecs = append(s.AcceptedVideoCodecs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptedVideoCodecs\"")
			}
		case "bframes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Bframes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bframes\"")
			}
		case "cqMode":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.CqMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cqMode\"")
			}
		case "crf":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Crf = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crf\"")
			}
		case "gopSize":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.GopSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gopSize\"")
			}
		case "maxBitrate":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MaxBitrate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxBitrate\"")
			}
		case "preferredHwDevice":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PreferredHwDevice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredHwDevice\"")
			}
		case "preset":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Preset = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preset\"")
			}
		case "refs":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Refs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refs\"")
			}
		case "targetAudioCodec":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.TargetAudioCodec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetAudioCodec\"")
			}
		case "targetResolution":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TargetResolution = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetResolution\"")
			}
		case "targetVideoCodec":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TargetVideoCodec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetVideoCodec\"")
			}
		case "temporalAQ":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.TemporalAQ = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temporalAQ\"")
			}
		case "threads":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Threads = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threads\"")
			}
		case "tonemap":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tonemap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tonemap\"")
			}
		case "transcode":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Transcode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcode\"")
			}
		case "twoPass":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.TwoPass = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twoPass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigFFmpegDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigFFmpegDto) {
					name = jsonFieldsNameOfSystemConfigFFmpegDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigFFmpegDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigFFmpegDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigFacesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigFacesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("import")
		e.Bool(s.Import)
	}
}

var jsonFieldsNameOfSystemConfigFacesDto = [1]string{
	0: "import",
}

// Decode decodes SystemConfigFacesDto from json.
func (s *SystemConfigFacesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigFacesDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "import":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Import = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigFacesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigFacesDto) {
					name = jsonFieldsNameOfSystemConfigFacesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigFacesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigFacesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigGeneratedFullsizeImageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigGeneratedFullsizeImageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		e.FieldStart("quality")
		e.Int(s.Quality)
	}
}

var jsonFieldsNameOfSystemConfigGeneratedFullsizeImageDto = [3]string{
	0: "enabled",
	1: "format",
	2: "quality",
}

// Decode decodes SystemConfigGeneratedFullsizeImageDto from json.
func (s *SystemConfigGeneratedFullsizeImageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigGeneratedFullsizeImageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "format":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "quality":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Quality = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigGeneratedFullsizeImageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigGeneratedFullsizeImageDto) {
					name = jsonFieldsNameOfSystemConfigGeneratedFullsizeImageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigGeneratedFullsizeImageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigGeneratedFullsizeImageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigGeneratedImageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigGeneratedImageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		e.FieldStart("quality")
		e.Int(s.Quality)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
}

var jsonFieldsNameOfSystemConfigGeneratedImageDto = [3]string{
	0: "format",
	1: "quality",
	2: "size",
}

// Decode decodes SystemConfigGeneratedImageDto from json.
func (s *SystemConfigGeneratedImageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigGeneratedImageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "quality":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quality = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigGeneratedImageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigGeneratedImageDto) {
					name = jsonFieldsNameOfSystemConfigGeneratedImageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigGeneratedImageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigGeneratedImageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigImageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigImageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("colorspace")
		s.Colorspace.Encode(e)
	}
	{
		e.FieldStart("extractEmbedded")
		e.Bool(s.ExtractEmbedded)
	}
	{
		e.FieldStart("fullsize")
		s.Fullsize.Encode(e)
	}
	{
		e.FieldStart("preview")
		s.Preview.Encode(e)
	}
	{
		e.FieldStart("thumbnail")
		s.Thumbnail.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigImageDto = [5]string{
	0: "colorspace",
	1: "extractEmbedded",
	2: "fullsize",
	3: "preview",
	4: "thumbnail",
}

// Decode decodes SystemConfigImageDto from json.
func (s *SystemConfigImageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigImageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "colorspace":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Colorspace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"colorspace\"")
			}
		case "extractEmbedded":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ExtractEmbedded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extractEmbedded\"")
			}
		case "fullsize":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Fullsize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullsize\"")
			}
		case "preview":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Preview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preview\"")
			}
		case "thumbnail":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Thumbnail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigImageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigImageDto) {
					name = jsonFieldsNameOfSystemConfigImageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigImageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigImageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigJobDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigJobDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backgroundTask")
		s.BackgroundTask.Encode(e)
	}
	{
		e.FieldStart("faceDetection")
		s.FaceDetection.Encode(e)
	}
	{
		e.FieldStart("library")
		s.Library.Encode(e)
	}
	{
		e.FieldStart("metadataExtraction")
		s.MetadataExtraction.Encode(e)
	}
	{
		e.FieldStart("migration")
		s.Migration.Encode(e)
	}
	{
		e.FieldStart("notifications")
		s.Notifications.Encode(e)
	}
	{
		e.FieldStart("search")
		s.Search.Encode(e)
	}
	{
		e.FieldStart("sidecar")
		s.Sidecar.Encode(e)
	}
	{
		e.FieldStart("smartSearch")
		s.SmartSearch.Encode(e)
	}
	{
		e.FieldStart("thumbnailGeneration")
		s.ThumbnailGeneration.Encode(e)
	}
	{
		e.FieldStart("videoConversion")
		s.VideoConversion.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigJobDto = [11]string{
	0:  "backgroundTask",
	1:  "faceDetection",
	2:  "library",
	3:  "metadataExtraction",
	4:  "migration",
	5:  "notifications",
	6:  "search",
	7:  "sidecar",
	8:  "smartSearch",
	9:  "thumbnailGeneration",
	10: "videoConversion",
}

// Decode decodes SystemConfigJobDto from json.
func (s *SystemConfigJobDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigJobDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backgroundTask":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BackgroundTask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backgroundTask\"")
			}
		case "faceDetection":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.FaceDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faceDetection\"")
			}
		case "library":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Library.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"library\"")
			}
		case "metadataExtraction":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.MetadataExtraction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadataExtraction\"")
			}
		case "migration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		case "notifications":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Notifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "search":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Search.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search\"")
			}
		case "sidecar":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sidecar.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidecar\"")
			}
		case "smartSearch":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SmartSearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smartSearch\"")
			}
		case "thumbnailGeneration":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.ThumbnailGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnailGeneration\"")
			}
		case "videoConversion":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.VideoConversion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videoConversion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigJobDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigJobDto) {
					name = jsonFieldsNameOfSystemConfigJobDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigJobDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigJobDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigLibraryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigLibraryDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("scan")
		s.Scan.Encode(e)
	}
	{
		e.FieldStart("watch")
		s.Watch.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigLibraryDto = [2]string{
	0: "scan",
	1: "watch",
}

// Decode decodes SystemConfigLibraryDto from json.
func (s *SystemConfigLibraryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigLibraryDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scan":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Scan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scan\"")
			}
		case "watch":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Watch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigLibraryDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigLibraryDto) {
					name = jsonFieldsNameOfSystemConfigLibraryDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigLibraryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigLibraryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigLibraryScanDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigLibraryScanDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cronExpression")
		e.Str(s.CronExpression)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfSystemConfigLibraryScanDto = [2]string{
	0: "cronExpression",
	1: "enabled",
}

// Decode decodes SystemConfigLibraryScanDto from json.
func (s *SystemConfigLibraryScanDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigLibraryScanDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cronExpression":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CronExpression = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cronExpression\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigLibraryScanDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigLibraryScanDto) {
					name = jsonFieldsNameOfSystemConfigLibraryScanDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigLibraryScanDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigLibraryScanDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigLibraryWatchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigLibraryWatchDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfSystemConfigLibraryWatchDto = [1]string{
	0: "enabled",
}

// Decode decodes SystemConfigLibraryWatchDto from json.
func (s *SystemConfigLibraryWatchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigLibraryWatchDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigLibraryWatchDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigLibraryWatchDto) {
					name = jsonFieldsNameOfSystemConfigLibraryWatchDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigLibraryWatchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigLibraryWatchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigLoggingDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigLoggingDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigLoggingDto = [2]string{
	0: "enabled",
	1: "level",
}

// Decode decodes SystemConfigLoggingDto from json.
func (s *SystemConfigLoggingDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigLoggingDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigLoggingDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigLoggingDto) {
					name = jsonFieldsNameOfSystemConfigLoggingDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigLoggingDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigLoggingDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigMachineLearningDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigMachineLearningDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("availabilityChecks")
		s.AvailabilityChecks.Encode(e)
	}
	{
		e.FieldStart("clip")
		s.Clip.Encode(e)
	}
	{
		e.FieldStart("duplicateDetection")
		s.DuplicateDetection.Encode(e)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("facialRecognition")
		s.FacialRecognition.Encode(e)
	}
	{
		e.FieldStart("urls")
		e.ArrStart()
		for _, elem := range s.Urls {
			json.EncodeURI(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSystemConfigMachineLearningDto = [6]string{
	0: "availabilityChecks",
	1: "clip",
	2: "duplicateDetection",
	3: "enabled",
	4: "facialRecognition",
	5: "urls",
}

// Decode decodes SystemConfigMachineLearningDto from json.
func (s *SystemConfigMachineLearningDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigMachineLearningDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "availabilityChecks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AvailabilityChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availabilityChecks\"")
			}
		case "clip":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Clip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clip\"")
			}
		case "duplicateDetection":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DuplicateDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateDetection\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "facialRecognition":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FacialRecognition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facialRecognition\"")
			}
		case "urls":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Urls = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem url.URL
					v, err := json.DecodeURI(d)
					elem = v
					if err != nil {
						return err
					}
					s.Urls = append(s.Urls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigMachineLearningDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigMachineLearningDto) {
					name = jsonFieldsNameOfSystemConfigMachineLearningDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigMachineLearningDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigMachineLearningDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigMapDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigMapDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("darkStyle")
		json.EncodeURI(e, s.DarkStyle)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("lightStyle")
		json.EncodeURI(e, s.LightStyle)
	}
}

var jsonFieldsNameOfSystemConfigMapDto = [3]string{
	0: "darkStyle",
	1: "enabled",
	2: "lightStyle",
}

// Decode decodes SystemConfigMapDto from json.
func (s *SystemConfigMapDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigMapDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "darkStyle":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DarkStyle = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"darkStyle\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "lightStyle":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LightStyle = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lightStyle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigMapDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigMapDto) {
					name = jsonFieldsNameOfSystemConfigMapDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigMapDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigMapDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigMetadataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigMetadataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("faces")
		s.Faces.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigMetadataDto = [1]string{
	0: "faces",
}

// Decode decodes SystemConfigMetadataDto from json.
func (s *SystemConfigMetadataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigMetadataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "faces":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Faces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigMetadataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigMetadataDto) {
					name = jsonFieldsNameOfSystemConfigMetadataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigMetadataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigMetadataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigNewVersionCheckDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigNewVersionCheckDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfSystemConfigNewVersionCheckDto = [1]string{
	0: "enabled",
}

// Decode decodes SystemConfigNewVersionCheckDto from json.
func (s *SystemConfigNewVersionCheckDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigNewVersionCheckDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigNewVersionCheckDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigNewVersionCheckDto) {
					name = jsonFieldsNameOfSystemConfigNewVersionCheckDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigNewVersionCheckDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigNewVersionCheckDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigNightlyTasksDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigNightlyTasksDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clusterNewFaces")
		e.Bool(s.ClusterNewFaces)
	}
	{
		e.FieldStart("databaseCleanup")
		e.Bool(s.DatabaseCleanup)
	}
	{
		e.FieldStart("generateMemories")
		e.Bool(s.GenerateMemories)
	}
	{
		e.FieldStart("missingThumbnails")
		e.Bool(s.MissingThumbnails)
	}
	{
		e.FieldStart("startTime")
		e.Str(s.StartTime)
	}
	{
		e.FieldStart("syncQuotaUsage")
		e.Bool(s.SyncQuotaUsage)
	}
}

var jsonFieldsNameOfSystemConfigNightlyTasksDto = [6]string{
	0: "clusterNewFaces",
	1: "databaseCleanup",
	2: "generateMemories",
	3: "missingThumbnails",
	4: "startTime",
	5: "syncQuotaUsage",
}

// Decode decodes SystemConfigNightlyTasksDto from json.
func (s *SystemConfigNightlyTasksDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigNightlyTasksDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterNewFaces":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ClusterNewFaces = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterNewFaces\"")
			}
		case "databaseCleanup":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.DatabaseCleanup = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databaseCleanup\"")
			}
		case "generateMemories":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.GenerateMemories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateMemories\"")
			}
		case "missingThumbnails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.MissingThumbnails = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"missingThumbnails\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StartTime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "syncQuotaUsage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SyncQuotaUsage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"syncQuotaUsage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigNightlyTasksDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigNightlyTasksDto) {
					name = jsonFieldsNameOfSystemConfigNightlyTasksDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigNightlyTasksDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigNightlyTasksDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigNotificationsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigNotificationsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("smtp")
		s.SMTP.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigNotificationsDto = [1]string{
	0: "smtp",
}

// Decode decodes SystemConfigNotificationsDto from json.
func (s *SystemConfigNotificationsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigNotificationsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "smtp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.SMTP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigNotificationsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigNotificationsDto) {
					name = jsonFieldsNameOfSystemConfigNotificationsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigNotificationsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigNotificationsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigOAuthDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigOAuthDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("autoLaunch")
		e.Bool(s.AutoLaunch)
	}
	{
		e.FieldStart("autoRegister")
		e.Bool(s.AutoRegister)
	}
	{
		e.FieldStart("buttonText")
		e.Str(s.ButtonText)
	}
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		e.FieldStart("clientSecret")
		e.Str(s.ClientSecret)
	}
	{
		e.FieldStart("defaultStorageQuota")
		s.DefaultStorageQuota.Encode(e)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("issuerUrl")
		e.Str(s.IssuerUrl)
	}
	{
		e.FieldStart("mobileOverrideEnabled")
		e.Bool(s.MobileOverrideEnabled)
	}
	{
		e.FieldStart("mobileRedirectUri")
		json.EncodeURI(e, s.MobileRedirectUri)
	}
	{
		e.FieldStart("profileSigningAlgorithm")
		e.Str(s.ProfileSigningAlgorithm)
	}
	{
		e.FieldStart("roleClaim")
		e.Str(s.RoleClaim)
	}
	{
		e.FieldStart("scope")
		e.Str(s.Scope)
	}
	{
		e.FieldStart("signingAlgorithm")
		e.Str(s.SigningAlgorithm)
	}
	{
		e.FieldStart("storageLabelClaim")
		e.Str(s.StorageLabelClaim)
	}
	{
		e.FieldStart("storageQuotaClaim")
		e.Str(s.StorageQuotaClaim)
	}
	{
		e.FieldStart("timeout")
		e.Int(s.Timeout)
	}
	{
		e.FieldStart("tokenEndpointAuthMethod")
		s.TokenEndpointAuthMethod.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigOAuthDto = [18]string{
	0:  "autoLaunch",
	1:  "autoRegister",
	2:  "buttonText",
	3:  "clientId",
	4:  "clientSecret",
	5:  "defaultStorageQuota",
	6:  "enabled",
	7:  "issuerUrl",
	8:  "mobileOverrideEnabled",
	9:  "mobileRedirectUri",
	10: "profileSigningAlgorithm",
	11: "roleClaim",
	12: "scope",
	13: "signingAlgorithm",
	14: "storageLabelClaim",
	15: "storageQuotaClaim",
	16: "timeout",
	17: "tokenEndpointAuthMethod",
}

// Decode decodes SystemConfigOAuthDto from json.
func (s *SystemConfigOAuthDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigOAuthDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "autoLaunch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AutoLaunch = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoLaunch\"")
			}
		case "autoRegister":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.AutoRegister = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoRegister\"")
			}
		case "buttonText":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ButtonText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buttonText\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "defaultStorageQuota":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.DefaultStorageQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultStorageQuota\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "issuerUrl":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssuerUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuerUrl\"")
			}
		case "mobileOverrideEnabled":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.MobileOverrideEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mobileOverrideEnabled\"")
			}
		case "mobileRedirectUri":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MobileRedirectUri = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mobileRedirectUri\"")
			}
		case "profileSigningAlgorithm":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProfileSigningAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileSigningAlgorithm\"")
			}
		case "roleClaim":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.RoleClaim = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roleClaim\"")
			}
		case "scope":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Scope = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "signingAlgorithm":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SigningAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signingAlgorithm\"")
			}
		case "storageLabelClaim":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StorageLabelClaim = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageLabelClaim\"")
			}
		case "storageQuotaClaim":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StorageQuotaClaim = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageQuotaClaim\"")
			}
		case "timeout":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Timeout = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "tokenEndpointAuthMethod":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TokenEndpointAuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenEndpointAuthMethod\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigOAuthDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigOAuthDto) {
					name = jsonFieldsNameOfSystemConfigOAuthDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigOAuthDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigOAuthDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigPasswordLoginDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigPasswordLoginDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfSystemConfigPasswordLoginDto = [1]string{
	0: "enabled",
}

// Decode decodes SystemConfigPasswordLoginDto from json.
func (s *SystemConfigPasswordLoginDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigPasswordLoginDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigPasswordLoginDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigPasswordLoginDto) {
					name = jsonFieldsNameOfSystemConfigPasswordLoginDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigPasswordLoginDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigPasswordLoginDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigReverseGeocodingDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigReverseGeocodingDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfSystemConfigReverseGeocodingDto = [1]string{
	0: "enabled",
}

// Decode decodes SystemConfigReverseGeocodingDto from json.
func (s *SystemConfigReverseGeocodingDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigReverseGeocodingDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigReverseGeocodingDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigReverseGeocodingDto) {
					name = jsonFieldsNameOfSystemConfigReverseGeocodingDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigReverseGeocodingDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigReverseGeocodingDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigServerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigServerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("externalDomain")
		json.EncodeURI(e, s.ExternalDomain)
	}
	{
		e.FieldStart("loginPageMessage")
		e.Str(s.LoginPageMessage)
	}
	{
		e.FieldStart("publicUsers")
		e.Bool(s.PublicUsers)
	}
}

var jsonFieldsNameOfSystemConfigServerDto = [3]string{
	0: "externalDomain",
	1: "loginPageMessage",
	2: "publicUsers",
}

// Decode decodes SystemConfigServerDto from json.
func (s *SystemConfigServerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigServerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "externalDomain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ExternalDomain = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDomain\"")
			}
		case "loginPageMessage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LoginPageMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginPageMessage\"")
			}
		case "publicUsers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.PublicUsers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicUsers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigServerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigServerDto) {
					name = jsonFieldsNameOfSystemConfigServerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigServerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigServerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigSmtpDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigSmtpDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("replyTo")
		e.Str(s.ReplyTo)
	}
	{
		e.FieldStart("transport")
		s.Transport.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigSmtpDto = [4]string{
	0: "enabled",
	1: "from",
	2: "replyTo",
	3: "transport",
}

// Decode decodes SystemConfigSmtpDto from json.
func (s *SystemConfigSmtpDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigSmtpDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "replyTo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ReplyTo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replyTo\"")
			}
		case "transport":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Transport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigSmtpDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigSmtpDto) {
					name = jsonFieldsNameOfSystemConfigSmtpDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigSmtpDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigSmtpDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigSmtpTransportDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigSmtpTransportDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("ignoreCert")
		e.Bool(s.IgnoreCert)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("port")
		e.Float64(s.Port)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfSystemConfigSmtpTransportDto = [5]string{
	0: "host",
	1: "ignoreCert",
	2: "password",
	3: "port",
	4: "username",
}

// Decode decodes SystemConfigSmtpTransportDto from json.
func (s *SystemConfigSmtpTransportDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigSmtpTransportDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "ignoreCert":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IgnoreCert = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignoreCert\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Port = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigSmtpTransportDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigSmtpTransportDto) {
					name = jsonFieldsNameOfSystemConfigSmtpTransportDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigSmtpTransportDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigSmtpTransportDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigStorageTemplateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigStorageTemplateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("hashVerificationEnabled")
		e.Bool(s.HashVerificationEnabled)
	}
	{
		e.FieldStart("template")
		e.Str(s.Template)
	}
}

var jsonFieldsNameOfSystemConfigStorageTemplateDto = [3]string{
	0: "enabled",
	1: "hashVerificationEnabled",
	2: "template",
}

// Decode decodes SystemConfigStorageTemplateDto from json.
func (s *SystemConfigStorageTemplateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigStorageTemplateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "hashVerificationEnabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HashVerificationEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashVerificationEnabled\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Template = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigStorageTemplateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigStorageTemplateDto) {
					name = jsonFieldsNameOfSystemConfigStorageTemplateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigStorageTemplateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigStorageTemplateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigTemplateEmailsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigTemplateEmailsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albumInviteTemplate")
		e.Str(s.AlbumInviteTemplate)
	}
	{
		e.FieldStart("albumUpdateTemplate")
		e.Str(s.AlbumUpdateTemplate)
	}
	{
		e.FieldStart("welcomeTemplate")
		e.Str(s.WelcomeTemplate)
	}
}

var jsonFieldsNameOfSystemConfigTemplateEmailsDto = [3]string{
	0: "albumInviteTemplate",
	1: "albumUpdateTemplate",
	2: "welcomeTemplate",
}

// Decode decodes SystemConfigTemplateEmailsDto from json.
func (s *SystemConfigTemplateEmailsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigTemplateEmailsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumInviteTemplate":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AlbumInviteTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumInviteTemplate\"")
			}
		case "albumUpdateTemplate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AlbumUpdateTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumUpdateTemplate\"")
			}
		case "welcomeTemplate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WelcomeTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"welcomeTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigTemplateEmailsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigTemplateEmailsDto) {
					name = jsonFieldsNameOfSystemConfigTemplateEmailsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigTemplateEmailsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigTemplateEmailsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigTemplateStorageOptionDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigTemplateStorageOptionDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dayOptions")
		e.ArrStart()
		for _, elem := range s.DayOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hourOptions")
		e.ArrStart()
		for _, elem := range s.HourOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("minuteOptions")
		e.ArrStart()
		for _, elem := range s.MinuteOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("monthOptions")
		e.ArrStart()
		for _, elem := range s.MonthOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("presetOptions")
		e.ArrStart()
		for _, elem := range s.PresetOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("secondOptions")
		e.ArrStart()
		for _, elem := range s.SecondOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("weekOptions")
		e.ArrStart()
		for _, elem := range s.WeekOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("yearOptions")
		e.ArrStart()
		for _, elem := range s.YearOptions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSystemConfigTemplateStorageOptionDto = [8]string{
	0: "dayOptions",
	1: "hourOptions",
	2: "minuteOptions",
	3: "monthOptions",
	4: "presetOptions",
	5: "secondOptions",
	6: "weekOptions",
	7: "yearOptions",
}

// Decode decodes SystemConfigTemplateStorageOptionDto from json.
func (s *SystemConfigTemplateStorageOptionDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigTemplateStorageOptionDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dayOptions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.DayOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DayOptions = append(s.DayOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dayOptions\"")
			}
		case "hourOptions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.HourOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.HourOptions = append(s.HourOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hourOptions\"")
			}
		case "minuteOptions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.MinuteOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MinuteOptions = append(s.MinuteOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minuteOptions\"")
			}
		case "monthOptions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.MonthOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MonthOptions = append(s.MonthOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthOptions\"")
			}
		case "presetOptions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.PresetOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PresetOptions = append(s.PresetOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presetOptions\"")
			}
		case "secondOptions":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.SecondOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SecondOptions = append(s.SecondOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondOptions\"")
			}
		case "weekOptions":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.WeekOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WeekOptions = append(s.WeekOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekOptions\"")
			}
		case "yearOptions":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.YearOptions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.YearOptions = append(s.YearOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yearOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigTemplateStorageOptionDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigTemplateStorageOptionDto) {
					name = jsonFieldsNameOfSystemConfigTemplateStorageOptionDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigTemplateStorageOptionDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigTemplateStorageOptionDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigTemplatesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigTemplatesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
}

var jsonFieldsNameOfSystemConfigTemplatesDto = [1]string{
	0: "email",
}

// Decode decodes SystemConfigTemplatesDto from json.
func (s *SystemConfigTemplatesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigTemplatesDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigTemplatesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigTemplatesDto) {
					name = jsonFieldsNameOfSystemConfigTemplatesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigTemplatesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigTemplatesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigThemeDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigThemeDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("customCss")
		e.Str(s.CustomCss)
	}
}

var jsonFieldsNameOfSystemConfigThemeDto = [1]string{
	0: "customCss",
}

// Decode decodes SystemConfigThemeDto from json.
func (s *SystemConfigThemeDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigThemeDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "customCss":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomCss = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customCss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigThemeDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigThemeDto) {
					name = jsonFieldsNameOfSystemConfigThemeDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigThemeDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigThemeDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigTrashDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigTrashDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("days")
		e.Int(s.Days)
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfSystemConfigTrashDto = [2]string{
	0: "days",
	1: "enabled",
}

// Decode decodes SystemConfigTrashDto from json.
func (s *SystemConfigTrashDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigTrashDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Days = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"days\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigTrashDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigTrashDto) {
					name = jsonFieldsNameOfSystemConfigTrashDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigTrashDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigTrashDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemConfigUserDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemConfigUserDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("deleteDelay")
		e.Int(s.DeleteDelay)
	}
}

var jsonFieldsNameOfSystemConfigUserDto = [1]string{
	0: "deleteDelay",
}

// Decode decodes SystemConfigUserDto from json.
func (s *SystemConfigUserDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemConfigUserDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deleteDelay":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DeleteDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleteDelay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemConfigUserDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemConfigUserDto) {
					name = jsonFieldsNameOfSystemConfigUserDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemConfigUserDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemConfigUserDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagBulkAssetsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagBulkAssetsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("assetIds")
		e.ArrStart()
		for _, elem := range s.AssetIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("tagIds")
		e.ArrStart()
		for _, elem := range s.TagIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTagBulkAssetsDto = [2]string{
	0: "assetIds",
	1: "tagIds",
}

// Decode decodes TagBulkAssetsDto from json.
func (s *TagBulkAssetsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagBulkAssetsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assetIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AssetIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.AssetIds = append(s.AssetIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetIds\"")
			}
		case "tagIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.TagIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.TagIds = append(s.TagIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagBulkAssetsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagBulkAssetsDto) {
					name = jsonFieldsNameOfTagBulkAssetsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagBulkAssetsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagBulkAssetsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagBulkAssetsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagBulkAssetsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
}

var jsonFieldsNameOfTagBulkAssetsResponseDto = [1]string{
	0: "count",
}

// Decode decodes TagBulkAssetsResponseDto from json.
func (s *TagBulkAssetsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagBulkAssetsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagBulkAssetsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagBulkAssetsResponseDto) {
					name = jsonFieldsNameOfTagBulkAssetsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagBulkAssetsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagBulkAssetsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.ParentId.Set {
			e.FieldStart("parentId")
			s.ParentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagCreateDto = [3]string{
	0: "color",
	1: "name",
	2: "parentId",
}

// Decode decodes TagCreateDto from json.
func (s *TagCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagCreateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parentId":
			if err := func() error {
				s.ParentId.Reset()
				if err := s.ParentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagCreateDto) {
					name = jsonFieldsNameOfTagCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.ParentId.Set {
			e.FieldStart("parentId")
			s.ParentId.Encode(e)
		}
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfTagResponseDto = [7]string{
	0: "color",
	1: "createdAt",
	2: "id",
	3: "name",
	4: "parentId",
	5: "updatedAt",
	6: "value",
}

// Decode decodes TagResponseDto from json.
func (s *TagResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parentId":
			if err := func() error {
				s.ParentId.Reset()
				if err := s.ParentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentId\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagResponseDto) {
					name = jsonFieldsNameOfTagResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagUpdateDto = [1]string{
	0: "color",
}

// Decode decodes TagUpdateDto from json.
func (s *TagUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagUpsertDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagUpsertDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTagUpsertDto = [1]string{
	0: "tags",
}

// Decode decodes TagUpsertDto from json.
func (s *TagUpsertDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagUpsertDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagUpsertDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagUpsertDto) {
					name = jsonFieldsNameOfTagUpsertDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagUpsertDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagUpsertDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("sidebarWeb")
		e.Bool(s.SidebarWeb)
	}
}

var jsonFieldsNameOfTagsResponse = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes TagsResponse from json.
func (s *TagsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagsResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SidebarWeb = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagsResponse) {
					name = jsonFieldsNameOfTagsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagsUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagsUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.SidebarWeb.Set {
			e.FieldStart("sidebarWeb")
			s.SidebarWeb.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagsUpdate = [2]string{
	0: "enabled",
	1: "sidebarWeb",
}

// Decode decodes TagsUpdate from json.
func (s *TagsUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagsUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "sidebarWeb":
			if err := func() error {
				s.SidebarWeb.Reset()
				if err := s.SidebarWeb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidebarWeb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagsUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagsUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagsUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("template")
		e.Str(s.Template)
	}
}

var jsonFieldsNameOfTemplateDto = [1]string{
	0: "template",
}

// Decode decodes TemplateDto from json.
func (s *TemplateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Template = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemplateDto) {
					name = jsonFieldsNameOfTemplateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("html")
		e.Str(s.HTML)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfTemplateResponseDto = [2]string{
	0: "html",
	1: "name",
}

// Decode decodes TemplateResponseDto from json.
func (s *TemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemplateResponseDto) {
					name = jsonFieldsNameOfTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestEmailResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestEmailResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("messageId")
		e.Str(s.MessageId)
	}
}

var jsonFieldsNameOfTestEmailResponseDto = [1]string{
	0: "messageId",
}

// Decode decodes TestEmailResponseDto from json.
func (s *TestEmailResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestEmailResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messageId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MessageId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messageId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestEmailResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestEmailResponseDto) {
					name = jsonFieldsNameOfTestEmailResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestEmailResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestEmailResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeBucketAssetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeBucketAssetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("city")
		e.ArrStart()
		for _, elem := range s.City {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("country")
		e.ArrStart()
		for _, elem := range s.Country {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("duration")
		e.ArrStart()
		for _, elem := range s.Duration {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("fileCreatedAt")
		e.ArrStart()
		for _, elem := range s.FileCreatedAt {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.ArrStart()
		for _, elem := range s.ID {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("isFavorite")
		e.ArrStart()
		for _, elem := range s.IsFavorite {
			e.Bool(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("isImage")
		e.ArrStart()
		for _, elem := range s.IsImage {
			e.Bool(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("isTrashed")
		e.ArrStart()
		for _, elem := range s.IsTrashed {
			e.Bool(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Latitude != nil {
			e.FieldStart("latitude")
			e.ArrStart()
			for _, elem := range s.Latitude {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("livePhotoVideoId")
		e.ArrStart()
		for _, elem := range s.LivePhotoVideoId {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("localOffsetHours")
		e.ArrStart()
		for _, elem := range s.LocalOffsetHours {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Longitude != nil {
			e.FieldStart("longitude")
			e.ArrStart()
			for _, elem := range s.Longitude {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("ownerId")
		e.ArrStart()
		for _, elem := range s.OwnerId {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("projectionType")
		e.ArrStart()
		for _, elem := range s.ProjectionType {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ratio")
		e.ArrStart()
		for _, elem := range s.Ratio {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Stack != nil {
			e.FieldStart("stack")
			e.ArrStart()
			for _, elem := range s.Stack {
				if elem == nil {
					e.Null()
				} else {
					e.ArrStart()
					for _, elem := range elem {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("thumbhash")
		e.ArrStart()
		for _, elem := range s.Thumbhash {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("visibility")
		e.ArrStart()
		for _, elem := range s.Visibility {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTimeBucketAssetResponseDto = [18]string{
	0:  "city",
	1:  "country",
	2:  "duration",
	3:  "fileCreatedAt",
	4:  "id",
	5:  "isFavorite",
	6:  "isImage",
	7:  "isTrashed",
	8:  "latitude",
	9:  "livePhotoVideoId",
	10: "localOffsetHours",
	11: "longitude",
	12: "ownerId",
	13: "projectionType",
	14: "ratio",
	15: "stack",
	16: "thumbhash",
	17: "visibility",
}

// Decode decodes TimeBucketAssetResponseDto from json.
func (s *TimeBucketAssetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeBucketAssetResponseDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "city":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.City = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.City = append(s.City, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Country = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Country = append(s.Country, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Duration = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Duration = append(s.Duration, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "fileCreatedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.FileCreatedAt = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileCreatedAt = append(s.FileCreatedAt, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileCreatedAt\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.ID = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ID = append(s.ID, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isFavorite":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.IsFavorite = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem bool
					v, err := d.Bool()
					elem = bool(v)
					if err != nil {
						return err
					}
					s.IsFavorite = append(s.IsFavorite, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "isImage":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.IsImage = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem bool
					v, err := d.Bool()
					elem = bool(v)
					if err != nil {
						return err
					}
					s.IsImage = append(s.IsImage, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isImage\"")
			}
		case "isTrashed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.IsTrashed = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem bool
					v, err := d.Bool()
					elem = bool(v)
					if err != nil {
						return err
					}
					s.IsTrashed = append(s.IsTrashed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrashed\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude = make([]NilFloat64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilFloat64
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Latitude = append(s.Latitude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "livePhotoVideoId":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.LivePhotoVideoId = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LivePhotoVideoId = append(s.LivePhotoVideoId, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livePhotoVideoId\"")
			}
		case "localOffsetHours":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.LocalOffsetHours = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.LocalOffsetHours = append(s.LocalOffsetHours, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localOffsetHours\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude = make([]NilFloat64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilFloat64
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Longitude = append(s.Longitude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "ownerId":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.OwnerId = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OwnerId = append(s.OwnerId, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		case "projectionType":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.ProjectionType = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ProjectionType = append(s.ProjectionType, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectionType\"")
			}
		case "ratio":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Ratio = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.Ratio = append(s.Ratio, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratio\"")
			}
		case "stack":
			if err := func() error {
				s.Stack = make([][]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []string
					switch tt := d.Next(); tt {
					case jx.Null:
						if err := d.Skip(); err != nil {
							return err
						}
					default:
						elem = make([]string, 0)
						if err := d.Arr(func(d *jx.Decoder) error {
							var elemElem string
							v, err := d.Str()
							elemElem = string(v)
							if err != nil {
								return err
							}
							elem = append(elem, elemElem)
							return nil
						}); err != nil {
							return err
						}
					}
					s.Stack = append(s.Stack, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stack\"")
			}
		case "thumbhash":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				s.Thumbhash = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Thumbhash = append(s.Thumbhash, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbhash\"")
			}
		case "visibility":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				s.Visibility = make([]AssetVisibility, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AssetVisibility
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Visibility = append(s.Visibility, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeBucketAssetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b01110110,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTimeBucketAssetResponseDto) {
					name = jsonFieldsNameOfTimeBucketAssetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeBucketAssetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeBucketAssetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeBucketsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeBucketsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
	{
		e.FieldStart("timeBucket")
		e.Str(s.TimeBucket)
	}
}

var jsonFieldsNameOfTimeBucketsResponseDto = [2]string{
	0: "count",
	1: "timeBucket",
}

// Decode decodes TimeBucketsResponseDto from json.
func (s *TimeBucketsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeBucketsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "timeBucket":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TimeBucket = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeBucket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeBucketsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTimeBucketsResponseDto) {
					name = jsonFieldsNameOfTimeBucketsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeBucketsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeBucketsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToneMapping as json.
func (s ToneMapping) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToneMapping from json.
func (s *ToneMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToneMapping to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToneMapping(v) {
	case ToneMappingHable:
		*s = ToneMappingHable
	case ToneMappingMobius:
		*s = ToneMappingMobius
	case ToneMappingReinhard:
		*s = ToneMappingReinhard
	case ToneMappingDisabled:
		*s = ToneMappingDisabled
	default:
		*s = ToneMapping(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToneMapping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToneMapping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscodeHWAccel as json.
func (s TranscodeHWAccel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TranscodeHWAccel from json.
func (s *TranscodeHWAccel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscodeHWAccel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TranscodeHWAccel(v) {
	case TranscodeHWAccelNvenc:
		*s = TranscodeHWAccelNvenc
	case TranscodeHWAccelQsv:
		*s = TranscodeHWAccelQsv
	case TranscodeHWAccelVaapi:
		*s = TranscodeHWAccelVaapi
	case TranscodeHWAccelRkmpp:
		*s = TranscodeHWAccelRkmpp
	case TranscodeHWAccelDisabled:
		*s = TranscodeHWAccelDisabled
	default:
		*s = TranscodeHWAccel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TranscodeHWAccel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscodeHWAccel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscodePolicy as json.
func (s TranscodePolicy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TranscodePolicy from json.
func (s *TranscodePolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscodePolicy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TranscodePolicy(v) {
	case TranscodePolicyAll:
		*s = TranscodePolicyAll
	case TranscodePolicyOptimal:
		*s = TranscodePolicyOptimal
	case TranscodePolicyBitrate:
		*s = TranscodePolicyBitrate
	case TranscodePolicyRequired:
		*s = TranscodePolicyRequired
	case TranscodePolicyDisabled:
		*s = TranscodePolicyDisabled
	default:
		*s = TranscodePolicy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TranscodePolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscodePolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TrashResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TrashResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
}

var jsonFieldsNameOfTrashResponseDto = [1]string{
	0: "count",
}

// Decode decodes TrashResponseDto from json.
func (s *TrashResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TrashResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TrashResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTrashResponseDto) {
					name = jsonFieldsNameOfTrashResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TrashResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TrashResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAlbumDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAlbumDto) encodeFields(e *jx.Encoder) {
	{
		if s.AlbumName.Set {
			e.FieldStart("albumName")
			s.AlbumName.Encode(e)
		}
	}
	{
		if s.AlbumThumbnailAssetId.Set {
			e.FieldStart("albumThumbnailAssetId")
			s.AlbumThumbnailAssetId.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.IsActivityEnabled.Set {
			e.FieldStart("isActivityEnabled")
			s.IsActivityEnabled.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateAlbumDto = [5]string{
	0: "albumName",
	1: "albumThumbnailAssetId",
	2: "description",
	3: "isActivityEnabled",
	4: "order",
}

// Decode decodes UpdateAlbumDto from json.
func (s *UpdateAlbumDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAlbumDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albumName":
			if err := func() error {
				s.AlbumName.Reset()
				if err := s.AlbumName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumName\"")
			}
		case "albumThumbnailAssetId":
			if err := func() error {
				s.AlbumThumbnailAssetId.Reset()
				if err := s.AlbumThumbnailAssetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albumThumbnailAssetId\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "isActivityEnabled":
			if err := func() error {
				s.IsActivityEnabled.Reset()
				if err := s.IsActivityEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActivityEnabled\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAlbumDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAlbumDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAlbumDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAlbumUserDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAlbumUserDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
}

var jsonFieldsNameOfUpdateAlbumUserDto = [1]string{
	0: "role",
}

// Decode decodes UpdateAlbumUserDto from json.
func (s *UpdateAlbumUserDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAlbumUserDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAlbumUserDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateAlbumUserDto) {
					name = jsonFieldsNameOfUpdateAlbumUserDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAlbumUserDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAlbumUserDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAssetDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAssetDto) encodeFields(e *jx.Encoder) {
	{
		if s.DateTimeOriginal.Set {
			e.FieldStart("dateTimeOriginal")
			s.DateTimeOriginal.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.IsFavorite.Set {
			e.FieldStart("isFavorite")
			s.IsFavorite.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.LivePhotoVideoId.Set {
			e.FieldStart("livePhotoVideoId")
			s.LivePhotoVideoId.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateAssetDto = [8]string{
	0: "dateTimeOriginal",
	1: "description",
	2: "isFavorite",
	3: "latitude",
	4: "livePhotoVideoId",
	5: "longitude",
	6: "rating",
	7: "visibility",
}

// Decode decodes UpdateAssetDto from json.
func (s *UpdateAssetDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAssetDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dateTimeOriginal":
			if err := func() error {
				s.DateTimeOriginal.Reset()
				if err := s.DateTimeOriginal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTimeOriginal\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "isFavorite":
			if err := func() error {
				s.IsFavorite.Reset()
				if err := s.IsFavorite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFavorite\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "livePhotoVideoId":
			if err := func() error {
				s.LivePhotoVideoId.Reset()
				if err := s.LivePhotoVideoId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livePhotoVideoId\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAssetDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAssetDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAssetDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateLibraryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateLibraryDto) encodeFields(e *jx.Encoder) {
	{
		if s.ExclusionPatterns != nil {
			e.FieldStart("exclusionPatterns")
			e.ArrStart()
			for _, elem := range s.ExclusionPatterns {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportPaths != nil {
			e.FieldStart("importPaths")
			e.ArrStart()
			for _, elem := range s.ImportPaths {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateLibraryDto = [3]string{
	0: "exclusionPatterns",
	1: "importPaths",
	2: "name",
}

// Decode decodes UpdateLibraryDto from json.
func (s *UpdateLibraryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLibraryDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exclusionPatterns":
			if err := func() error {
				s.ExclusionPatterns = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExclusionPatterns = append(s.ExclusionPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusionPatterns\"")
			}
		case "importPaths":
			if err := func() error {
				s.ImportPaths = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ImportPaths = append(s.ImportPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPaths\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateLibraryDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLibraryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLibraryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsageByUserDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsageByUserDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("photos")
		e.Int(s.Photos)
	}
	{
		e.FieldStart("quotaSizeInBytes")
		s.QuotaSizeInBytes.Encode(e)
	}
	{
		e.FieldStart("usage")
		e.Int64(s.Usage)
	}
	{
		e.FieldStart("usagePhotos")
		e.Int64(s.UsagePhotos)
	}
	{
		e.FieldStart("usageVideos")
		e.Int64(s.UsageVideos)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
	{
		e.FieldStart("userName")
		e.Str(s.UserName)
	}
	{
		e.FieldStart("videos")
		e.Int(s.Videos)
	}
}

var jsonFieldsNameOfUsageByUserDto = [8]string{
	0: "photos",
	1: "quotaSizeInBytes",
	2: "usage",
	3: "usagePhotos",
	4: "usageVideos",
	5: "userId",
	6: "userName",
	7: "videos",
}

// Decode decodes UsageByUserDto from json.
func (s *UsageByUserDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageByUserDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "photos":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Photos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photos\"")
			}
		case "quotaSizeInBytes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.QuotaSizeInBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaSizeInBytes\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Usage = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "usagePhotos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.UsagePhotos = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usagePhotos\"")
			}
		case "usageVideos":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.UsageVideos = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageVideos\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "videos":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Videos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"videos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageByUserDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsageByUserDto) {
					name = jsonFieldsNameOfUsageByUserDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsageByUserDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageByUserDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAdminCreateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAdminCreateDto) encodeFields(e *jx.Encoder) {
	{
		if s.AvatarColor.Set {
			e.FieldStart("avatarColor")
			s.AvatarColor.Encode(e)
		}
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.IsAdmin.Set {
			e.FieldStart("isAdmin")
			s.IsAdmin.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Notify.Set {
			e.FieldStart("notify")
			s.Notify.Encode(e)
		}
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		if s.QuotaSizeInBytes.Set {
			e.FieldStart("quotaSizeInBytes")
			s.QuotaSizeInBytes.Encode(e)
		}
	}
	{
		if s.ShouldChangePassword.Set {
			e.FieldStart("shouldChangePassword")
			s.ShouldChangePassword.Encode(e)
		}
	}
	{
		if s.StorageLabel.Set {
			e.FieldStart("storageLabel")
			s.StorageLabel.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAdminCreateDto = [9]string{
	0: "avatarColor",
	1: "email",
	2: "isAdmin",
	3: "name",
	4: "notify",
	5: "password",
	6: "quotaSizeInBytes",
	7: "shouldChangePassword",
	8: "storageLabel",
}

// Decode decodes UserAdminCreateDto from json.
func (s *UserAdminCreateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAdminCreateDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatarColor":
			if err := func() error {
				s.AvatarColor.Reset()
				if err := s.AvatarColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatarColor\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "isAdmin":
			if err := func() error {
				s.IsAdmin.Reset()
				if err := s.IsAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAdmin\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notify":
			if err := func() error {
				s.Notify.Reset()
				if err := s.Notify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notify\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "quotaSizeInBytes":
			if err := func() error {
				s.QuotaSizeInBytes.Reset()
				if err := s.QuotaSizeInBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaSizeInBytes\"")
			}
		case "shouldChangePassword":
			if err := func() error {
				s.ShouldChangePassword.Reset()
				if err := s.ShouldChangePassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shouldChangePassword\"")
			}
		case "storageLabel":
			if err := func() error {
				s.StorageLabel.Reset()
				if err := s.StorageLabel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageLabel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAdminCreateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00101010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAdminCreateDto) {
					name = jsonFieldsNameOfUserAdminCreateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAdminCreateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAdminCreateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAdminDeleteDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAdminDeleteDto) encodeFields(e *jx.Encoder) {
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAdminDeleteDto = [1]string{
	0: "force",
}

// Decode decodes UserAdminDeleteDto from json.
func (s *UserAdminDeleteDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAdminDeleteDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAdminDeleteDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAdminDeleteDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAdminDeleteDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAdminResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAdminResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatarColor")
		s.AvatarColor.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("deletedAt")
		s.DeletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isAdmin")
		e.Bool(s.IsAdmin)
	}
	{
		e.FieldStart("license")
		s.License.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("oauthId")
		e.Str(s.OauthId)
	}
	{
		e.FieldStart("profileChangedAt")
		json.EncodeDateTime(e, s.ProfileChangedAt)
	}
	{
		e.FieldStart("profileImagePath")
		e.Str(s.ProfileImagePath)
	}
	{
		e.FieldStart("quotaSizeInBytes")
		s.QuotaSizeInBytes.Encode(e)
	}
	{
		e.FieldStart("quotaUsageInBytes")
		s.QuotaUsageInBytes.Encode(e)
	}
	{
		e.FieldStart("shouldChangePassword")
		e.Bool(s.ShouldChangePassword)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("storageLabel")
		s.StorageLabel.Encode(e)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUserAdminResponseDto = [17]string{
	0:  "avatarColor",
	1:  "createdAt",
	2:  "deletedAt",
	3:  "email",
	4:  "id",
	5:  "isAdmin",
	6:  "license",
	7:  "name",
	8:  "oauthId",
	9:  "profileChangedAt",
	10: "profileImagePath",
	11: "quotaSizeInBytes",
	12: "quotaUsageInBytes",
	13: "shouldChangePassword",
	14: "status",
	15: "storageLabel",
	16: "updatedAt",
}

// Decode decodes UserAdminResponseDto from json.
func (s *UserAdminResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAdminResponseDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatarColor":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AvatarColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatarColor\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "deletedAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isAdmin":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAdmin\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "oauthId":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OauthId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauthId\"")
			}
		case "profileChangedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ProfileChangedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileChangedAt\"")
			}
		case "profileImagePath":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProfileImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileImagePath\"")
			}
		case "quotaSizeInBytes":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.QuotaSizeInBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaSizeInBytes\"")
			}
		case "quotaUsageInBytes":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.QuotaUsageInBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaUsageInBytes\"")
			}
		case "shouldChangePassword":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ShouldChangePassword = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shouldChangePassword\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "storageLabel":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.StorageLabel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageLabel\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAdminResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAdminResponseDto) {
					name = jsonFieldsNameOfUserAdminResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAdminResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAdminResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAdminUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAdminUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.AvatarColor.Set {
			e.FieldStart("avatarColor")
			s.AvatarColor.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.IsAdmin.Set {
			e.FieldStart("isAdmin")
			s.IsAdmin.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PinCode.Set {
			e.FieldStart("pinCode")
			s.PinCode.Encode(e)
		}
	}
	{
		if s.QuotaSizeInBytes.Set {
			e.FieldStart("quotaSizeInBytes")
			s.QuotaSizeInBytes.Encode(e)
		}
	}
	{
		if s.ShouldChangePassword.Set {
			e.FieldStart("shouldChangePassword")
			s.ShouldChangePassword.Encode(e)
		}
	}
	{
		if s.StorageLabel.Set {
			e.FieldStart("storageLabel")
			s.StorageLabel.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAdminUpdateDto = [9]string{
	0: "avatarColor",
	1: "email",
	2: "isAdmin",
	3: "name",
	4: "password",
	5: "pinCode",
	6: "quotaSizeInBytes",
	7: "shouldChangePassword",
	8: "storageLabel",
}

// Decode decodes UserAdminUpdateDto from json.
func (s *UserAdminUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAdminUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatarColor":
			if err := func() error {
				s.AvatarColor.Reset()
				if err := s.AvatarColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatarColor\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "isAdmin":
			if err := func() error {
				s.IsAdmin.Reset()
				if err := s.IsAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAdmin\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "pinCode":
			if err := func() error {
				s.PinCode.Reset()
				if err := s.PinCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinCode\"")
			}
		case "quotaSizeInBytes":
			if err := func() error {
				s.QuotaSizeInBytes.Reset()
				if err := s.QuotaSizeInBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaSizeInBytes\"")
			}
		case "shouldChangePassword":
			if err := func() error {
				s.ShouldChangePassword.Reset()
				if err := s.ShouldChangePassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shouldChangePassword\"")
			}
		case "storageLabel":
			if err := func() error {
				s.StorageLabel.Reset()
				if err := s.StorageLabel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageLabel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAdminUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAdminUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAdminUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAvatarColor as json.
func (s UserAvatarColor) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserAvatarColor from json.
func (s *UserAvatarColor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAvatarColor to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserAvatarColor(v) {
	case UserAvatarColorPrimary:
		*s = UserAvatarColorPrimary
	case UserAvatarColorPink:
		*s = UserAvatarColorPink
	case UserAvatarColorRed:
		*s = UserAvatarColorRed
	case UserAvatarColorYellow:
		*s = UserAvatarColorYellow
	case UserAvatarColorBlue:
		*s = UserAvatarColorBlue
	case UserAvatarColorGreen:
		*s = UserAvatarColorGreen
	case UserAvatarColorPurple:
		*s = UserAvatarColorPurple
	case UserAvatarColorOrange:
		*s = UserAvatarColorOrange
	case UserAvatarColorGray:
		*s = UserAvatarColorGray
	case UserAvatarColorAmber:
		*s = UserAvatarColorAmber
	default:
		*s = UserAvatarColor(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserAvatarColor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAvatarColor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserLicense) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activatedAt")
		json.EncodeDateTime(e, s.ActivatedAt)
	}
	{
		e.FieldStart("activationKey")
		e.Str(s.ActivationKey)
	}
	{
		e.FieldStart("licenseKey")
		e.Str(s.LicenseKey)
	}
}

var jsonFieldsNameOfUserLicense = [3]string{
	0: "activatedAt",
	1: "activationKey",
	2: "licenseKey",
}

// Decode decodes UserLicense from json.
func (s *UserLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserLicense to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activatedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ActivatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activatedAt\"")
			}
		case "activationKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ActivationKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activationKey\"")
			}
		case "licenseKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LicenseKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserLicense")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserLicense) {
					name = jsonFieldsNameOfUserLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPreferencesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPreferencesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("albums")
		s.Albums.Encode(e)
	}
	{
		e.FieldStart("cast")
		s.Cast.Encode(e)
	}
	{
		e.FieldStart("download")
		s.Download.Encode(e)
	}
	{
		e.FieldStart("emailNotifications")
		s.EmailNotifications.Encode(e)
	}
	{
		e.FieldStart("folders")
		s.Folders.Encode(e)
	}
	{
		e.FieldStart("memories")
		s.Memories.Encode(e)
	}
	{
		e.FieldStart("people")
		s.People.Encode(e)
	}
	{
		e.FieldStart("purchase")
		s.Purchase.Encode(e)
	}
	{
		e.FieldStart("ratings")
		s.Ratings.Encode(e)
	}
	{
		e.FieldStart("sharedLinks")
		s.SharedLinks.Encode(e)
	}
	{
		e.FieldStart("tags")
		s.Tags.Encode(e)
	}
}

var jsonFieldsNameOfUserPreferencesResponseDto = [11]string{
	0:  "albums",
	1:  "cast",
	2:  "download",
	3:  "emailNotifications",
	4:  "folders",
	5:  "memories",
	6:  "people",
	7:  "purchase",
	8:  "ratings",
	9:  "sharedLinks",
	10: "tags",
}

// Decode decodes UserPreferencesResponseDto from json.
func (s *UserPreferencesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPreferencesResponseDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albums":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Albums.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albums\"")
			}
		case "cast":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Cast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cast\"")
			}
		case "download":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Download.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download\"")
			}
		case "emailNotifications":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EmailNotifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emailNotifications\"")
			}
		case "folders":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Folders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folders\"")
			}
		case "memories":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Memories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memories\"")
			}
		case "people":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.People.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"people\"")
			}
		case "purchase":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Purchase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purchase\"")
			}
		case "ratings":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Ratings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratings\"")
			}
		case "sharedLinks":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SharedLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharedLinks\"")
			}
		case "tags":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPreferencesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserPreferencesResponseDto) {
					name = jsonFieldsNameOfUserPreferencesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPreferencesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPreferencesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPreferencesUpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPreferencesUpdateDto) encodeFields(e *jx.Encoder) {
	{
		if s.Albums.Set {
			e.FieldStart("albums")
			s.Albums.Encode(e)
		}
	}
	{
		if s.Avatar.Set {
			e.FieldStart("avatar")
			s.Avatar.Encode(e)
		}
	}
	{
		if s.Cast.Set {
			e.FieldStart("cast")
			s.Cast.Encode(e)
		}
	}
	{
		if s.Download.Set {
			e.FieldStart("download")
			s.Download.Encode(e)
		}
	}
	{
		if s.EmailNotifications.Set {
			e.FieldStart("emailNotifications")
			s.EmailNotifications.Encode(e)
		}
	}
	{
		if s.Folders.Set {
			e.FieldStart("folders")
			s.Folders.Encode(e)
		}
	}
	{
		if s.Memories.Set {
			e.FieldStart("memories")
			s.Memories.Encode(e)
		}
	}
	{
		if s.People.Set {
			e.FieldStart("people")
			s.People.Encode(e)
		}
	}
	{
		if s.Purchase.Set {
			e.FieldStart("purchase")
			s.Purchase.Encode(e)
		}
	}
	{
		if s.Ratings.Set {
			e.FieldStart("ratings")
			s.Ratings.Encode(e)
		}
	}
	{
		if s.SharedLinks.Set {
			e.FieldStart("sharedLinks")
			s.SharedLinks.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserPreferencesUpdateDto = [12]string{
	0:  "albums",
	1:  "avatar",
	2:  "cast",
	3:  "download",
	4:  "emailNotifications",
	5:  "folders",
	6:  "memories",
	7:  "people",
	8:  "purchase",
	9:  "ratings",
	10: "sharedLinks",
	11: "tags",
}

// Decode decodes UserPreferencesUpdateDto from json.
func (s *UserPreferencesUpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPreferencesUpdateDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "albums":
			if err := func() error {
				s.Albums.Reset()
				if err := s.Albums.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"albums\"")
			}
		case "avatar":
			if err := func() error {
				s.Avatar.Reset()
				if err := s.Avatar.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar\"")
			}
		case "cast":
			if err := func() error {
				s.Cast.Reset()
				if err := s.Cast.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cast\"")
			}
		case "download":
			if err := func() error {
				s.Download.Reset()
				if err := s.Download.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download\"")
			}
		case "emailNotifications":
			if err := func() error {
				s.EmailNotifications.Reset()
				if err := s.EmailNotifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emailNotifications\"")
			}
		case "folders":
			if err := func() error {
				s.Folders.Reset()
				if err := s.Folders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folders\"")
			}
		case "memories":
			if err := func() error {
				s.Memories.Reset()
				if err := s.Memories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memories\"")
			}
		case "people":
			if err := func() error {
				s.People.Reset()
				if err := s.People.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"people\"")
			}
		case "purchase":
			if err := func() error {
				s.Purchase.Reset()
				if err := s.Purchase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purchase\"")
			}
		case "ratings":
			if err := func() error {
				s.Ratings.Reset()
				if err := s.Ratings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratings\"")
			}
		case "sharedLinks":
			if err := func() error {
				s.SharedLinks.Reset()
				if err := s.SharedLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharedLinks\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPreferencesUpdateDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPreferencesUpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPreferencesUpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("avatarColor")
		s.AvatarColor.Encode(e)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("profileChangedAt")
		json.EncodeDateTime(e, s.ProfileChangedAt)
	}
	{
		e.FieldStart("profileImagePath")
		e.Str(s.ProfileImagePath)
	}
}

var jsonFieldsNameOfUserResponseDto = [6]string{
	0: "avatarColor",
	1: "email",
	2: "id",
	3: "name",
	4: "profileChangedAt",
	5: "profileImagePath",
}

// Decode decodes UserResponseDto from json.
func (s *UserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatarColor":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AvatarColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatarColor\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "profileChangedAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ProfileChangedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileChangedAt\"")
			}
		case "profileImagePath":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ProfileImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileImagePath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserResponseDto) {
					name = jsonFieldsNameOfUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatus as json.
func (s UserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserStatus from json.
func (s *UserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserStatus(v) {
	case UserStatusActive:
		*s = UserStatusActive
	case UserStatusRemoving:
		*s = UserStatusRemoving
	case UserStatusDeleted:
		*s = UserStatusDeleted
	default:
		*s = UserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserUpdateMeDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserUpdateMeDto) encodeFields(e *jx.Encoder) {
	{
		if s.AvatarColor.Set {
			e.FieldStart("avatarColor")
			s.AvatarColor.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserUpdateMeDto = [4]string{
	0: "avatarColor",
	1: "email",
	2: "name",
	3: "password",
}

// Decode decodes UserUpdateMeDto from json.
func (s *UserUpdateMeDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUpdateMeDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatarColor":
			if err := func() error {
				s.AvatarColor.Reset()
				if err := s.AvatarColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatarColor\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUpdateMeDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserUpdateMeDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUpdateMeDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateAccessTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateAccessTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("authStatus")
		e.Bool(s.AuthStatus)
	}
}

var jsonFieldsNameOfValidateAccessTokenResponseDto = [1]string{
	0: "authStatus",
}

// Decode decodes ValidateAccessTokenResponseDto from json.
func (s *ValidateAccessTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateAccessTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authStatus":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AuthStatus = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateAccessTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidateAccessTokenResponseDto) {
					name = jsonFieldsNameOfValidateAccessTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateAccessTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateAccessTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateLibraryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateLibraryDto) encodeFields(e *jx.Encoder) {
	{
		if s.ExclusionPatterns != nil {
			e.FieldStart("exclusionPatterns")
			e.ArrStart()
			for _, elem := range s.ExclusionPatterns {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportPaths != nil {
			e.FieldStart("importPaths")
			e.ArrStart()
			for _, elem := range s.ImportPaths {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidateLibraryDto = [2]string{
	0: "exclusionPatterns",
	1: "importPaths",
}

// Decode decodes ValidateLibraryDto from json.
func (s *ValidateLibraryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateLibraryDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exclusionPatterns":
			if err := func() error {
				s.ExclusionPatterns = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExclusionPatterns = append(s.ExclusionPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusionPatterns\"")
			}
		case "importPaths":
			if err := func() error {
				s.ImportPaths = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ImportPaths = append(s.ImportPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPaths\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateLibraryDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateLibraryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateLibraryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateLibraryImportPathResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateLibraryImportPathResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("importPath")
		e.Str(s.ImportPath)
	}
	{
		e.FieldStart("isValid")
		e.Bool(s.IsValid)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidateLibraryImportPathResponseDto = [3]string{
	0: "importPath",
	1: "isValid",
	2: "message",
}

// Decode decodes ValidateLibraryImportPathResponseDto from json.
func (s *ValidateLibraryImportPathResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateLibraryImportPathResponseDto to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "importPath":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ImportPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPath\"")
			}
		case "isValid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isValid\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateLibraryImportPathResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidateLibraryImportPathResponseDto) {
					name = jsonFieldsNameOfValidateLibraryImportPathResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateLibraryImportPathResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateLibraryImportPathResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidateLibraryResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidateLibraryResponseDto) encodeFields(e *jx.Encoder) {
	{
		if s.ImportPaths != nil {
			e.FieldStart("importPaths")
			e.ArrStart()
			for _, elem := range s.ImportPaths {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidateLibraryResponseDto = [1]string{
	0: "importPaths",
}

// Decode decodes ValidateLibraryResponseDto from json.
func (s *ValidateLibraryResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidateLibraryResponseDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "importPaths":
			if err := func() error {
				s.ImportPaths = make([]ValidateLibraryImportPathResponseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidateLibraryImportPathResponseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImportPaths = append(s.ImportPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPaths\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidateLibraryResponseDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidateLibraryResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidateLibraryResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionCheckStateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionCheckStateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("checkedAt")
		s.CheckedAt.Encode(e)
	}
	{
		e.FieldStart("releaseVersion")
		s.ReleaseVersion.Encode(e)
	}
}

var jsonFieldsNameOfVersionCheckStateResponseDto = [2]string{
	0: "checkedAt",
	1: "releaseVersion",
}

// Decode decodes VersionCheckStateResponseDto from json.
func (s *VersionCheckStateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionCheckStateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "checkedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CheckedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkedAt\"")
			}
		case "releaseVersion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ReleaseVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releaseVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionCheckStateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVersionCheckStateResponseDto) {
					name = jsonFieldsNameOfVersionCheckStateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionCheckStateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionCheckStateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoCodec as json.
func (s VideoCodec) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VideoCodec from json.
func (s *VideoCodec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoCodec to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VideoCodec(v) {
	case VideoCodecH264:
		*s = VideoCodecH264
	case VideoCodecHevc:
		*s = VideoCodecHevc
	case VideoCodecVp9:
		*s = VideoCodecVp9
	case VideoCodecAv1:
		*s = VideoCodecAv1
	default:
		*s = VideoCodec(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VideoCodec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoCodec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VideoContainer as json.
func (s VideoContainer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VideoContainer from json.
func (s *VideoContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VideoContainer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VideoContainer(v) {
	case VideoContainerMov:
		*s = VideoContainerMov
	case VideoContainerMP4:
		*s = VideoContainerMP4
	case VideoContainerOgg:
		*s = VideoContainerOgg
	case VideoContainerWebm:
		*s = VideoContainerWebm
	default:
		*s = VideoContainer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VideoContainer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VideoContainer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
